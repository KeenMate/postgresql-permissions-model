/*
 GROUP HEADERS GENERATED BY: https://patorjk.com/software/taag/#p=display&h=0&v=1&c=c&f=ANSI%20Shadow&t=STAGE%20FUNCS

 SUB GROUP HEADERS GENERATED BY: https://patorjk.com/software/taag/#p=display&h=1&v=1&c=c&f=Banner3&t=permissions

 */

select *
from start_version_update('1.2', '', _component := 'keen_auth_permissions');


drop function auth.set_token_as_used(_modified_by text,
																									_user_id bigint,
																									_token_uid text,
																									_token text,
																									_token_type_code text,
																									_ip_address text,
																									_user_agent text,
																									_origin text
);
create or replace function auth.set_token_as_used(_modified_by text,
																									_user_id bigint,
																									_token_uid text,
																									_token text,
																									_token_type_code text,
																									_ip_address text,
																									_user_agent text,
																									_origin text
)
	returns table
					(
						__token_id         bigint,
						__token_uid        text,
						__token_state_code text,
						__used_at          timestamptz,
						__user_id          bigint,
						__user_oid         text,
						__token_data 			 jsonb
					)
	language plpgsql
as
$$
declare
	__token_id  bigint;
	__token_uid text;
begin

	perform
		auth.has_permission(_user_id, 'tokens.set_as_used');

	select token_id, uid
	from auth.token
	where (helpers.is_not_empty_string(_token_uid) or helpers.is_not_empty_string(_token))
		and uid = _token_uid
		and token = _token
		and token_type_code = _token_type_code
		and token_state_code = 'valid'
	into __token_id, __token_uid;


	-- 	if helpers.is_empty_string(__token_uid) then
-- 		perform error.raise_52278(__token_uid);
-- 	end if;

	return query
		update auth.token
			set modified_by = _modified_by, modified = now(), token_state_code = 'used', used_at = now(), ip_address = _ip_address, user_agent = _user_agent, origin = _origin
			where
					(helpers.is_empty_string(_token_uid) or _token_uid = uid)
					and token = _token
			returning token_id
				, uid
				, token_state_code
				, used_at
				, user_id
				, user_oid
				, token_data;

	perform
		add_journal_msg(_modified_by, _user_id
			, format('Token (uid: %s) set as used by user: %s'
											, _token_uid, _modified_by)
			, 'token', __token_id
			, array ['ip_address', _ip_address, 'user_agent', _user_agent, 'origin', _origin]
			, _event_id := 50403
			, _tenant_id := 1);

end;
$$;

drop function auth.validate_token(_modified_by text, _user_id bigint,
																							 _target_user_id bigint,
																							 _token_uid text,
																							 _token text,
																							 _token_type text,
																							 _ip_address text,
																							 _user_agent text,
																							 _origin text,
																							 _set_as_used bool);
create or replace function auth.validate_token(_modified_by text, _user_id bigint,
																							 _target_user_id bigint,
																							 _token_uid text,
																							 _token text,
																							 _token_type text,
																							 _ip_address text,
																							 _user_agent text,
																							 _origin text,
																							 _set_as_used bool default false)
	returns table
					(
						___token_id         bigint,
						___token_uid        text,
						___token_state_code text,
						___used_at          timestamptz,
						___user_id          bigint,
						___user_oid         text,
						___token_data				jsonb
					)
	language plpgsql
as
$$
declare
	__token_id         bigint;
	__token_uid        text;
	__token_state_code text;
	__token_user_id    bigint;
begin
	perform
		auth.has_permission(_user_id, 'tokens.validate_token');

	select token_id, uid, token_state_code, user_id
	from auth.token
	where ((_target_user_id is not null and token.user_id = _target_user_id) or true)
		and token_type_code = _token_type
		and (helpers.is_not_empty_string(_token_uid) or helpers.is_not_empty_string(_token))
		and (helpers.is_empty_string(_token_uid) or uid = _token_uid)
		and (helpers.is_empty_string(_token) or token = _token)
	into __token_id, __token_uid, __token_state_code, __token_user_id;

	if
		__token_id is null then
		perform error.raise_52277();
	end if;

	if
		__token_state_code <> 'valid' then
		perform error.raise_52278(__token_uid);
	end if;

	if
		_target_user_id is not null and _target_user_id <> __token_user_id then
		perform error.raise_52279(__token_uid);
	end if;

	perform
		add_journal_msg(_modified_by, _user_id
			, format('User: %s validated a token for user: %s'
											, _modified_by, _target_user_id)
			, 'token', __token_id
			, array ['ip_address', _ip_address, 'user_agent', _user_agent, 'origin', _origin]
			, 50402
			, _tenant_id := 1);


	if
		_set_as_used then
		return query
			select used_token.__token_id
					 , used_token.__token_uid
					 , used_token.__token_state_code
					 , used_token.__used_at
					 , used_token.__user_id
					 , used_token.__user_oid
					 , used_token.__token_data
			from auth.set_token_as_used(_modified_by, _user_id, __token_uid, _token,
																	_token_type, _ip_address, _user_agent,
																	_origin) used_token;
	else
		return query
			select token_id, uid, token_state_code, used_at, user_id, user_oid, token_data
			from auth.token
			where token_id = __token_id;
	end if;


	perform unsecure.expire_tokens(_modified_by);
end;
$$;

select *
from stop_version_update('1.2', _component := 'keen_auth_permissions');
