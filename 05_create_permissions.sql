/*
 GROUP HEADERS GENERATED BY: https://patorjk.com/software/taag/#p=display&h=0&v=1&c=c&f=ANSI%20Shadow&t=STAGE%20FUNCS

 SUB GROUP HEADERS GENERATED BY: https://patorjk.com/software/taag/#p=display&h=1&v=1&c=c&f=Banner3&t=permissions

 */

select *
from start_version_update('1', 'Initial version', _component := 'keen_auth_permissions');

/***
 *    ███████╗██╗  ██╗████████╗███████╗███╗   ██╗███████╗██╗ ██████╗ ███╗   ██╗███████╗
 *    ██╔════╝╚██╗██╔╝╚══██╔══╝██╔════╝████╗  ██║██╔════╝██║██╔═══██╗████╗  ██║██╔════╝
 *    █████╗   ╚███╔╝    ██║   █████╗  ██╔██╗ ██║███████╗██║██║   ██║██╔██╗ ██║███████╗
 *    ██╔══╝   ██╔██╗    ██║   ██╔══╝  ██║╚██╗██║╚════██║██║██║   ██║██║╚██╗██║╚════██║
 *    ███████╗██╔╝ ██╗   ██║   ███████╗██║ ╚████║███████║██║╚██████╔╝██║ ╚████║███████║
 *    ╚══════╝╚═╝  ╚═╝   ╚═╝   ╚══════╝╚═╝  ╚═══╝╚══════╝╚═╝ ╚═════╝ ╚═╝  ╚═══╝╚══════╝
 *
 */

-- Ensure necessary extensions

create
    extension if not exists "uuid-ossp" schema ext;
create
    extension if not exists ltree schema ext;
create
    extension if not exists unaccent schema ext;


/***
 *    ███████╗██████╗ ██████╗  ██████╗ ██████╗ ███████╗
 *    ██╔════╝██╔══██╗██╔══██╗██╔═══██╗██╔══██╗██╔════╝
 *    █████╗  ██████╔╝██████╔╝██║   ██║██████╔╝███████╗
 *    ██╔══╝  ██╔══██╗██╔══██╗██║   ██║██╔══██╗╚════██║
 *    ███████╗██║  ██║██║  ██║╚██████╔╝██║  ██║███████║
 *    ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝ ╚═════╝ ╚═╝  ╚═╝╚══════╝
 *
 */

-- Cannot ensure user for email provider

create function error.raise_52101(_username text) returns void
    language plpgsql as
$$
begin

    raise
        exception 'User (username: %) cannot be ensured for email provider, use registration for that', _username
        using errcode = 52101;
end;
$$;

-- User cannot register user because the identity is already in use

create function error.raise_52102(_normalized_email text) returns void
    language plpgsql as
$$
begin

    raise
        exception 'User identity (uid: %) is already in use', _normalized_email
        using errcode = 52102;
end;
$$;

-- User does not exist

create function error.raise_52103(_user_id bigint, _email text default null) returns void
    language plpgsql as
$$
begin

    raise
        exception 'User (user id: %, email: %) does not exist'
        , _user_id, _email
        using errcode = 52103;
end;
$$;

-- User is a system user

create function error.raise_52104(_user_id bigint) returns void
    language plpgsql as
$$
begin

    raise
        exception 'User (user id: %) is a system user'
        , _user_id
        using errcode = 52104;
end;
$$;

-- User is in inactive state

create function error.raise_52105(_user_id bigint) returns void
    language plpgsql as
$$
begin

    raise
        exception 'User (id: %) is not in active state', _user_id
        using errcode = 52105;
end;
$$;

-- User is locked

create function error.raise_52106(_email text) returns void
    language plpgsql as
$$
begin

    raise
        exception 'User (email: %) is locked out', _email
        using errcode = 52106;
end;
$$;

-- Provider is not active

create function error.raise_52107(_provider_code text) returns void
    language plpgsql as
$$
begin

    raise
        exception 'Provider (provider code: %) is not in active state', _provider_code
        using errcode = 52107;
end;
$$;

-- User has no access to tenant

create function error.raise_52108(_tenant_id text, _username text) returns void
    language plpgsql as
$$
begin

    raise
        exception 'User(username: %) has no access to tenant(id: %)', _username, _tenant_id
        using errcode = 52108;
end;
$$;

-- User has no correct permission in tenant

create function error.raise_52109(_user_id bigint, _tenant_id int, _perm_codes text[]) returns void
    language plpgsql as
$$
begin

    raise
        exception 'User(id: %) has no permission (codes: %) in tenant(id: %)', _user_id, array_to_string(_perm_codes, '; '), _tenant_id
        using errcode = 52109;
end;
$$;

-- User provider identity is not active

create function error.raise_52110(_user_id bigint, _provider_code text) returns void
    language plpgsql as
$$
begin

    raise
        exception 'User (id: %) identity for provider (code: %) is not in active state', _user_id, _provider_code
        using errcode = 52110;
end;
$$;

-- User provider identity does not exist

create function error.raise_52111(_user_id bigint, _provider_code text) returns void
    language plpgsql as
$$
begin

    raise
        exception 'User (id: %) identity for provider (code: %) does not exist', _user_id, _provider_code
        using errcode = 52111;
end;
$$;

-- User provider identity does not exist

create function error.raise_52112(_user_id bigint) returns void
    language plpgsql as
$$
begin

    raise
        exception 'User (id: %) is not supposed to log in', _user_id
        using errcode = 52112;
end;
$$;

-- User group not found

create function error.raise_52171(_user_group_id int) returns void
    language plpgsql as
$$
begin

    raise
        exception 'User group (group id: %) does not exist'
        , _user_group_id
        using errcode = 52171;
end;
$$;

-- User cannot be added to group because the group is not active

create function error.raise_52172(_user_group_id int) returns void
    language plpgsql as
$$
begin

    raise
        exception 'User group (group id: %) is not active'
        , _user_group_id
        using errcode = 52172;
end;
$$;

-- User cannot be added to group because it's either not assignable or a

create function error.raise_52173(_user_group_id int) returns void
    language plpgsql as
$$
begin

    raise
        exception 'User group (group id: %) is either is not assignable or is external'
        , _user_group_id
        using errcode = 52173;
end;
$$;

-- Either mapped object id or role must not be empty

create function error.raise_52174() returns void
    language plpgsql as
$$
begin

    raise
        exception 'Either mapped object id or mapped role must not be empty'
        using errcode = 52174;
end;
$$;

-- Permission set is not assignable

create function error.raise_52175(_perm_set_code text) returns void
    language plpgsql as
$$
begin

    raise
        exception 'Permission set (code: %) is not assignable'
        , _perm_set_code
        using errcode = 52175;
end;
$$;

-- Permission is not assignable

create function error.raise_52176(_perm_set_code text) returns void
    language plpgsql as
$$
begin

    raise
        exception 'Permission (code: %) is not assignable'
        , _perm_set_code
        using errcode = 52176;
end;
$$;

-- Permission set is not defined in tenant

create function error.raise_52177(_perm_set_id int, _tenant_id int) returns void
    language plpgsql as
$$
begin

    raise
        exception 'Permission set (id: %) is not defined in tenant (id: %)', _perm_set_id, _tenant_id
        using errcode = 52177;
end;
$$;

-- Permission is not assignable

create function error.raise_52178() returns void
    language plpgsql as
$$
begin

    raise
        exception 'Some permissions are not assignable'
        using errcode = 52178;
end;
$$;

-- User group cannot be deleted because it's a system group

create function error.raise_52271(_user_group_id int) returns void
    language plpgsql as
$$
begin

    raise
        exception 'User: group (group id: %) is a system group'
        , _user_group_id
        using errcode = 52271;
end;
$$;

-- Either user group id or target user id has to be not null

create function error.raise_52272() returns void
    language plpgsql as
$$
begin

    raise
        exception 'Either user group is or target user id must not be null'
        using errcode = 52272;
end;
$$;

-- Either permission set code or permission code has to be not null

create function error.raise_52273() returns void
    language plpgsql as
$$
begin

    raise
        exception 'Either permission set code or permission code must not be null'
        using errcode = 52273;
end;
$$;

-- Either permission id or code has to be not null

create function error.raise_52274() returns void
    language plpgsql as
$$
begin

    raise
        exception 'Either permission id or code has to be not null'
        using errcode = 52274;
end;
$$;

-- Permission does not exist

create function error.raise_52275(_permission_full_code text) returns void
    language plpgsql as
$$
begin

    raise
        exception 'Permission (full code: %s) does not exist'
        , _permission_full_code
        using errcode = 52275;
end;
$$;

-- The same token is already used

create function error.raise_52276() returns void
    language plpgsql as
$$
begin

    raise
        exception 'The same token is already used'
        using errcode = 52276;
end;
$$;

-- Token does not exist

create function error.raise_52277() returns void
    language plpgsql as
$$
begin

    raise
        exception 'Token does not exist'
        using errcode = 52277;
end;
$$;

-- Token is not valid or has expired

create function error.raise_52278(_token_uid text) returns void
    language plpgsql as
$$
begin

    raise
        exception 'Token (uid: %) is not valid or has expired', _token_uid
        using errcode = 52278;
end;
$$;

-- Token was created for different user

create function error.raise_52279(_token_uid text) returns void
    language plpgsql as
$$
begin

    raise
        exception 'Token (uid: %) was created for different user', _token_uid
        using errcode = 52279;
end;
$$;

-- User is not tenant owner
create function error.raise_52280(_user_id bigint, _tenant_id int) returns void
    language plpgsql as
$$
begin

    raise
        exception 'User (uid: %) is not tenant (id: %) owner', _user_id, _tenant_id
        using errcode = 52280;
end;
$$;

-- User is not tenant or user group owner
create function error.raise_52281(_user_id bigint, _tenant_id int, _user_group_id int) returns void
    language plpgsql as
$$
begin

    raise
        exception 'User (uid: %) is not tenant (id: %) or user group (id: %) owner', _user_id, _tenant_id, _user_group_id
        using errcode = 52281;
end;
$$;

/***
 *    ██╗--██╗███████╗██╗-----██████╗-███████╗██████╗-███████╗
 *    ██║--██║██╔════╝██║-----██╔══██╗██╔════╝██╔══██╗██╔════╝
 *    ███████║█████╗--██║-----██████╔╝█████╗--██████╔╝███████╗
 *    ██╔══██║██╔══╝--██║-----██╔═══╝-██╔══╝--██╔══██╗╚════██║
 *    ██║--██║███████╗███████╗██║-----███████╗██║--██║███████║
 *    ╚═╝--╚═╝╚══════╝╚══════╝╚═╝-----╚══════╝╚═╝--╚═╝╚══════╝
 *    --------------------------------------------------------
 */

create function auth.get_user_random_code()
    returns text
    language sql
    immutable
    cost 1
as
$$
select helpers.random_string(8);
$$;

/***
 *    ████████╗███████╗███╗---███╗██████╗-██╗------█████╗-████████╗███████╗███████╗
 *    ╚══██╔══╝██╔════╝████╗-████║██╔══██╗██║-----██╔══██╗╚══██╔══╝██╔════╝██╔════╝
 *    ---██║---█████╗--██╔████╔██║██████╔╝██║-----███████║---██║---█████╗--███████╗
 *    ---██║---██╔══╝--██║╚██╔╝██║██╔═══╝-██║-----██╔══██║---██║---██╔══╝--╚════██║
 *    ---██║---███████╗██║-╚═╝-██║██║-----███████╗██║--██║---██║---███████╗███████║
 *    ---╚═╝---╚══════╝╚═╝-----╚═╝╚═╝-----╚══════╝╚═╝--╚═╝---╚═╝---╚══════╝╚══════╝
 *    -----------------------------------------------------------------------------
 */

create table public._template_created
(
    created    timestamp with time zone               default now()             not null,
    created_by text check (length(created_by) <= 250) default 'unknown' :: text not null
);

create table public._template_timestamps
(
    modified    timestamp with time zone                default now()             not null,
    modified_by text check (length(modified_by) <= 250) default 'unknown' :: text not null
) inherits (_template_created);

/***
 *    ████████╗██████╗-██╗-██████╗--██████╗-███████╗██████╗-███████╗
 *    ╚══██╔══╝██╔══██╗██║██╔════╝-██╔════╝-██╔════╝██╔══██╗██╔════╝
 *    ---██║---██████╔╝██║██║--███╗██║--███╗█████╗--██████╔╝███████╗
 *    ---██║---██╔══██╗██║██║---██║██║---██║██╔══╝--██╔══██╗╚════██║
 *    ---██║---██║--██║██║╚██████╔╝╚██████╔╝███████╗██║--██║███████║
 *    ---╚═╝---╚═╝--╚═╝╚═╝-╚═════╝--╚═════╝-╚══════╝╚═╝--╚═╝╚══════╝
 *    --------------------------------------------------------------
 */

CREATE
    OR REPLACE FUNCTION helpers.trg_generate_code_from_title()
    RETURNS trigger
    LANGUAGE plpgsql AS
$$
BEGIN
    NEW.code
        := helpers.get_code(NEW.title, '_');

    RETURN NEW;
END
$$;

/***
 *    ███████╗██╗   ██╗███████╗████████╗███████╗███╗   ███╗    ████████╗ █████╗ ██████╗ ██╗     ███████╗███████╗
 *    ██╔════╝╚██╗ ██╔╝██╔════╝╚══██╔══╝██╔════╝████╗ ████║    ╚══██╔══╝██╔══██╗██╔══██╗██║     ██╔════╝██╔════╝
 *    ███████╗ ╚████╔╝ ███████╗   ██║   █████╗  ██╔████╔██║       ██║   ███████║██████╔╝██║     █████╗  ███████╗
 *    ╚════██║  ╚██╔╝  ╚════██║   ██║   ██╔══╝  ██║╚██╔╝██║       ██║   ██╔══██║██╔══██╗██║     ██╔══╝  ╚════██║
 *    ███████║   ██║   ███████║   ██║   ███████╗██║ ╚═╝ ██║       ██║   ██║  ██║██████╔╝███████╗███████╗███████║
 *    ╚══════╝   ╚═╝   ╚══════╝   ╚═╝   ╚══════╝╚═╝     ╚═╝       ╚═╝   ╚═╝  ╚═╝╚═════╝ ╚══════╝╚══════╝╚══════╝
 *
 */

create table const.sys_param
(
    sys_param_id int generated always as identity not null primary key,
    group_code   text                             not null,
    code         text                             not null,
    text_value   text,
    number_value bigint,
    bool_value   bool
) inherits (_template_timestamps);

create unique index uq_sys_params on const.sys_param (group_code, code);

create table const.token_type
(
    code                          text not null primary key,
    default_expiration_in_seconds int
);

create table const.token_channel
(
    code text not null primary key
);

create table const.token_state
(
    code text not null primary key
);

create table const.auth_event_type
(
    code text not null primary key
);

create table auth.provider
(
    provider_id int generated always as identity not null primary key,
    code        text                             not null unique,
    name        text                             not null,
    is_active   bool                             not null default true
) inherits (_template_timestamps);

create table tenant
(
    tenant_id        int generated always as identity not null primary key,
    uuid             uuid                             not null default ext.uuid_generate_v4(), -- if you need this kind of identifier, it's ready for you
    title            text                             not null,
    code             text                             not null,
    is_removable     bool                             not null default true,
    is_assignable    bool                             not null default true,
    access_type_code bool                                                                      -- invitation_only, registration, all
) inherits (_template_timestamps);

create table user_info
(
    user_id                 bigint generated always as identity not null primary key,
    code                    text                                not null default auth.get_user_random_code(), -- if you need this kind of identifier, it's ready for you
    uuid                    uuid                                not null default ext.uuid_generate_v4(),      -- if you need this kind of identifier, it's ready for you
    can_login               bool                                not null default true,
    username                text                                not null check (length(username) <= 255 ),
    email                   text check (length(email) <= 255 ),
    display_name            text                                not null check (length(display_name) <= 255 ),
    is_system               bool                                not null default false,
    is_active               bool                                not null default true,
    is_locked               bool                                not null default false,
    last_used_provider_code text                                references auth.provider (code) on update set null
) inherits (_template_timestamps);

create unique index uq_user_info on user_info (email);

create table tenant_user
(
    tenant_user_id bigint generated always as identity not null primary key,
    tenant_id      int                                 not null references tenant (tenant_id) on delete cascade,
    user_id        int                                 not null references user_info (user_id) on delete cascade
) inherits (_template_created);

create table auth.user_permission_cache
(
    upc_id          bigint generated always as identity not null primary key,
    user_id         bigint                              not null references user_info (user_id),
    tenant_id       int                                 not null references tenant (tenant_id),
    groups          text[]                              not null default '{}',
    permissions     text[]                              not null default '{}',
    expiration_date timestamptz                         not null
) inherits (_template_timestamps);


-- can be replaced with your version of user data
create table user_data
(
    user_data_id bigint generated always as identity not null primary key,
    user_id      bigint                              not null references user_info (user_id) on delete cascade,
    first_name   text,
    middle_name  text,
    last_name    text

) inherits (_template_timestamps);

create table user_identity
(
    user_identity_id bigint generated always as identity not null primary key,
    provider_code    text                                not null references auth.provider (code) on update cascade on delete cascade,
    uid              text,
    user_id          bigint references user_info (user_id) on delete cascade,
    provider_groups  text[],
    provider_roles   text[],
    user_data        jsonb,
    password_hash    text,
    password_salt    text,
    is_active        bool                                not null default true
) inherits (_template_timestamps);

create unique index uq_user_identity on user_identity (provider_code, coalesce(uid, '-1'));

create table auth.permission
(
    permission_id int generated always as identity not null primary key,
    is_assignable bool                             not null default true,
    title         text                             not null,
    code          text,
    full_code     ext.ltree,
    node_path     ext.ltree,
    has_children  bool                             not null default false,
    full_title    text
) inherits (_template_timestamps);

create unique index uq_permission_full_code on auth.permission (full_code);
create index ix_permission_node_path on auth.permission using GIST (node_path);

create table auth.perm_set
(
    perm_set_id   int generated always as identity not null primary key,
    tenant_id     int references tenant (tenant_id) on delete cascade,
    title         text                             not null,
    code          text                             not null unique, -- set with trigger
    is_system     bool                             not null default false,
    is_assignable bool                             not null default true
) inherits (_template_timestamps);

create trigger c_perm_set_code
    before insert
    on auth.perm_set
    for each row
execute procedure helpers.trg_generate_code_from_title();

create table auth.perm_set_perm
(
    psp_id        int generated always as identity not null primary key,
    perm_set_id   int                              not null references auth.perm_set (perm_set_id) on delete cascade,
    permission_id int                              not null references auth.permission (permission_id) on delete cascade
) inherits (_template_created);

create table user_group
(
    user_group_id             int generated always as identity not null primary key,
    tenant_id                 int references tenant (tenant_id),
    title                     text                             not null,
    code                      text                             not null, -- set with trigger
    is_system                 bool                             not null default false,
    is_external               bool                             not null default false,
    is_assignable             bool                             not null default true,
    is_active                 bool                             not null default true,
    is_default                bool                             not null default false check ( is_external = false or (is_external and not is_default) ),
    can_members_manage_others bool                             not null default false,
    can_members_see_others    bool                             not null default true
) inherits (_template_timestamps);

create trigger c_user_group_code
    before insert
    on user_group
    for each row
execute procedure helpers.trg_generate_code_from_title();

create table user_group_mapping
(
    ug_mapping_id      int generated always as identity not null primary key,
    group_id           int                              not null references user_group (user_group_id),
    provider_code      text                             not null references auth.provider (code) on update cascade on delete cascade,
    mapped_object_id   text,
    mapped_object_name text,
    mapped_role        text
) inherits (_template_created);

create unique index uq_user_group_mapping on user_group_mapping (group_id, provider_code,
                                                                 coalesce(mapped_object_id, ''),
                                                                 coalesce(mapped_role, ''));

create table user_group_member
(
    member_id         bigint generated always as identity not null primary key,
    group_id          int                                 not null references user_group (user_group_id) on delete cascade,
    user_id           bigint                              not null references user_info (user_id) on delete cascade,
    mapping_id        int references user_group_mapping (ug_mapping_id) on delete cascade,
    manual_assignment bool                                not null default false
) inherits (_template_created);

create unique index uq_user_group_member ON user_group_member (group_id, user_id, coalesce(mapping_id, 0));

create table owner
(
    owner_id      bigint generated always as identity not null primary key,
    tenant_id     int                                 not null references tenant (tenant_id) on delete cascade,
    user_group_id int references user_group (user_group_id) on delete cascade,
    user_id       bigint                              not null references user_info (user_id) on delete cascade
) inherits (_template_created);

create unique index ix_owner on owner using btree (user_id, tenant_id, user_group_id);

create table auth.permission_assignment
(
    assignment_id int generated always as identity not null primary key,
    tenant_id     int references tenant (tenant_id) on delete cascade,
    group_id      int                              not null references user_group (user_group_id),
    user_id       bigint references user_info (user_id),
    perm_set_id   int references auth.perm_set (perm_set_id),
    permission_id int references auth.permission (permission_id),
    CONSTRAINT pa_either_object CHECK (group_id is not null or user_id is not null),
    CONSTRAINT pa_either_perm CHECK (perm_set_id is not null or permission_id is not null)
) inherits (_template_created);

create unique index uq_permission_assignment ON auth.permission_assignment (group_id, coalesce(user_id, 0),
                                                                            coalesce(perm_set_id, 0),
                                                                            coalesce(permission_id, 0));

create table auth.auth_event
(
    auth_event_id      bigint generated always as identity not null primary key,
    event_type_code    text                                not null references const.auth_event_type (code),
    requester_user_id  bigint                              references user_info (user_id) on delete set null,
    requester_username text,
    target_user_id     bigint                              references user_info (user_id) on delete set null,
    target_username    text,
    ip_address         text,
    user_agent         text,
    origin             text
) inherits (_template_created);

create table auth.token
(
    token_id           bigint generated always as identity not null primary key,
    user_id            bigint references user_info (user_id),
    uid                text                                not null default helpers.random_string(12) unique, -- token uid
    auth_event_id      int references auth.auth_event (auth_event_id) on delete cascade,                      -- related authentication event
    token_state_code   text                                not null default 'valid' references const.token_state (code),
    token_type_code    text                                not null references const.token_type (code),
    token_channel_code text                                not null references const.token_channel (code),
    token              text                                not null,
    expires_at         timestamptz                         not null,
    used_at            timestamptz,
    ip_address         text,
    user_agent         text,
    origin             text
) inherits (_template_timestamps);

create table journal
(
    journal_id     bigint generated always as identity not null,
    tenant_id      int references tenant (tenant_id),
    data_group     text,
    data_object_id bigint,
    event_id       int,
    user_id        bigint                              references user_info (user_id) on delete set null,
    message        text                                not null,
    data_payload   jsonb
) inherits (_template_created);

create index ix_journal on journal (tenant_id, data_group, data_object_id);

/***
 *    ██╗   ██╗██╗███████╗██╗    ██╗███████╗
 *    ██║   ██║██║██╔════╝██║    ██║██╔════╝
 *    ██║   ██║██║█████╗  ██║ █╗ ██║███████╗
 *    ╚██╗ ██╔╝██║██╔══╝  ██║███╗██║╚════██║
 *     ╚████╔╝ ██║███████╗╚███╔███╔╝███████║
 *      ╚═══╝  ╚═╝╚══════╝ ╚══╝╚══╝ ╚══════╝
 *
 */

create view user_group_members as
(
select ug.tenant_id
     , ugm.member_id
     , case when t.code is null then 'system' else t.code end                             as tenant_code
     , ui.user_id
     , ui.display_name                                                                    as user_display_name
     , ui.uuid                                                                            as user_uuid
     , ui.code                                                                            as user_code
     , ug.user_group_id
     , ug.is_external
     , ug.is_active
     , ug.is_assignable
     , ug.title                                                                           as group_title
     , ug.code                                                                            as group_code
     , case when ugm.mapping_id is not null then 'mapped_member' else 'direct_member' end as member_type
     , ugm.manual_assignment
     , u.mapped_object_name
     , u.mapped_role
from user_group ug
         left join user_group_member ugm on ugm.group_id = ug.user_group_id
         left join user_info ui
                   on ui.user_id = ugm.user_id
         inner join tenant t on ug.tenant_id = t.tenant_id
         left join user_group_mapping u on ugm.mapping_id = u.ug_mapping_id
    );

create view active_user_groups as
(
select ug.user_group_id
     , ug.is_system
     , ug.is_external
     , ug.is_assignable
     , ug.is_active
     , ug.is_default
     , ug.title as group_title
     , ug.code  as group_code
     , ug.tenant_id
     , t.code   as tenant_code
     , t.title  as tenant_title
from user_group ug
         left join tenant t on ug.tenant_id = t.tenant_id
where ug.is_active
    );

create view auth.effective_permissions as
(
select distinct ps.perm_set_id,
                ps.code          as perm_set_code,
                ps.title         as perm_set_title,
                ps.is_assignable as perm_set_is_assignable,
                sp.permission_id,
                sp.title         as permission_title,
                sp.full_code     as permission_code,
                sp.is_assignable as permission_is_assignable
from auth.perm_set ps
         inner join auth.perm_set_perm psp on ps.perm_set_id = psp.perm_set_id
         inner join auth.permission p on psp.permission_id = p.permission_id
         inner join auth.permission sp on sp.node_path <@ p.node_path);

/***
 *    -----██╗-██████╗-██╗---██╗██████╗-███╗---██╗-█████╗-██╗----------██████╗-██████╗-███████╗██████╗--█████╗-████████╗██╗-██████╗-███╗---██╗███████╗
 *    -----██║██╔═══██╗██║---██║██╔══██╗████╗--██║██╔══██╗██║---------██╔═══██╗██╔══██╗██╔════╝██╔══██╗██╔══██╗╚══██╔══╝██║██╔═══██╗████╗--██║██╔════╝
 *    -----██║██║---██║██║---██║██████╔╝██╔██╗-██║███████║██║---------██║---██║██████╔╝█████╗--██████╔╝███████║---██║---██║██║---██║██╔██╗-██║███████╗
 *    ██---██║██║---██║██║---██║██╔══██╗██║╚██╗██║██╔══██║██║---------██║---██║██╔═══╝-██╔══╝--██╔══██╗██╔══██║---██║---██║██║---██║██║╚██╗██║╚════██║
 *    ╚█████╔╝╚██████╔╝╚██████╔╝██║--██║██║-╚████║██║--██║███████╗----╚██████╔╝██║-----███████╗██║--██║██║--██║---██║---██║╚██████╔╝██║-╚████║███████║
 *    -╚════╝--╚═════╝--╚═════╝-╚═╝--╚═╝╚═╝--╚═══╝╚═╝--╚═╝╚══════╝-----╚═════╝-╚═╝-----╚══════╝╚═╝--╚═╝╚═╝--╚═╝---╚═╝---╚═╝-╚═════╝-╚═╝--╚═══╝╚══════╝
 *    ------------------------------------------------------------------------------------------------------------------------------------------------
 */

create
    or replace function add_journal_msg_jsonb(_created_by text, _tenant_id int, _user_id bigint, _msg text,
                                              _data_group text default 'system',
                                              _data_object_id bigint default null
    , _payload jsonb default null
    , _event_id int default null)
    returns setof journal
    language plpgsql
    rows 1
as
$$
begin
    return query insert into journal (created_by, tenant_id, data_group, data_object_id, event_id, user_id, message,
                                      data_payload)
        values (_created_by, _tenant_id, _data_group, _data_object_id, _event_id, _user_id, _msg,
                case when _payload is not null then _payload end)
        returning *;
end;
$$;

create
    or replace function add_journal_msg(_created_by text, _tenant_id int, _user_id bigint, _msg text,
                                        _data_group text default 'system',
                                        _data_object_id bigint default null
    , _payload text[] default null
    , _event_id int default null)
    returns setof journal
    language sql
as
$$

-- noinspection SqlConstantExpression

select *
from add_journal_msg_jsonb(_created_by, _tenant_id, _user_id, _msg, _data_group, _data_object_id,
                           case when _payload is null then null else jsonb_build_object(variadic _payload) end
    , _event_id)
$$;

create
    or replace function get_journal_msgs(_tenant_id int, _user_id int, _from timestamptz, _to timestamptz)
    returns table
            (
                __journal_id     bigint,
                __created        timestamptz,
                __created_by     text,
                __data_group     text,
                __data_object_id bigint,
                __user_id        bigint,
                __msg            text
            )
    language plpgsql
    stable
as
$$
begin
    perform
        auth.has_permission(_tenant_id, _user_id, 'system.journal.read_journal');

    select journal_id
         , created
         , created_by
         , data_group
         , data_object_id
         , user_id
         , message
    from journal
    where tenant_id = _tenant_id
      and created between _from and _to;
end;
$$;

create
    or replace function get_journal_payload(_tenant_id int, _user_id int, _journal_id bigint)
    returns table
            (
                __journal_id bigint,
                __payload    text
            )
    language plpgsql
    stable
    rows 1
as
$$
begin
    perform
        auth.has_permission(_tenant_id, _user_id, 'system.journal.get_payload');

    return query
        select journal_id
             , data_payload::text
        from journal
        where tenant_id = _tenant_id
          and journal_id = _journal_id;
end;
$$;


/***
 *    ███████╗██╗   ██╗███████╗    ███████╗██╗   ██╗███╗   ██╗ ██████╗████████╗██╗ ██████╗ ███╗   ██╗███████╗
 *    ██╔════╝╚██╗ ██╔╝██╔════╝    ██╔════╝██║   ██║████╗  ██║██╔════╝╚══██╔══╝██║██╔═══██╗████╗  ██║██╔════╝
 *    ███████╗ ╚████╔╝ ███████╗    █████╗  ██║   ██║██╔██╗ ██║██║        ██║   ██║██║   ██║██╔██╗ ██║███████╗
 *    ╚════██║  ╚██╔╝  ╚════██║    ██╔══╝  ██║   ██║██║╚██╗██║██║        ██║   ██║██║   ██║██║╚██╗██║╚════██║
 *    ███████║   ██║   ███████║    ██║     ╚██████╔╝██║ ╚████║╚██████╗   ██║   ██║╚██████╔╝██║ ╚████║███████║
 *    ╚══════╝   ╚═╝   ╚══════╝    ╚═╝      ╚═════╝ ╚═╝  ╚═══╝ ╚═════╝   ╚═╝   ╚═╝ ╚═════╝ ╚═╝  ╚═══╝╚══════╝
 *
 */

create function auth.throw_no_access(_tenant_id int, _username text)
    returns void
    language plpgsql
as
$$
begin
    perform
        error.raise_52108(_tenant_id, _username);
end;
$$;

create function auth.throw_no_permission(_tenant_id int, _user_id bigint, _perm_codes text[])
    returns void
    language plpgsql
as
$$
begin
    perform
        error.raise_52109(_user_id, _tenant_id, _perm_codes);
end;
$$;

create function auth.throw_no_permission(_tenant_id int, _user_id bigint, _perm_code text)
    returns void
    language plpgsql
as
$$
begin
    perform
        auth.throw_no_permission(_tenant_id, _user_id, array [_perm_code]);
end;
$$;

create
    or replace function unsecure.clear_permission_cache(_deleted_by text, _tenant_id int, _target_user_id bigint)
    returns void
    language sql
as
$$

delete
from auth.user_permission_cache
where tenant_id = _tenant_id
  and user_id = _target_user_id;
$$;

create
    or replace function unsecure.recalculate_user_groups(_created_by text,
                                                         _target_user_id bigint, _provider_code text)
    returns table
            (
                __groups text[]
            )
    language plpgsql
as
$$
declare
    __not_really_used int;
    __provider_groups text[];
    __provider_roles  text[];
begin

    select provider_groups, provider_roles
    from user_identity
    where provider_code = _provider_code
      and user_id = _target_user_id
    into __provider_groups, __provider_roles;

-- cleanup membership of groups user is no longer part of
    with affected_deleted_group_tenants as (
        delete
            from user_group_member
                where user_id = _target_user_id
                    and mapping_id is not null
                    and group_id not in (select distinct ugm.group_id
                                         from unnest(__provider_groups) g
                                                  inner join public.user_group_mapping ugm
                                                             on ugm.provider_code = _provider_code and ugm.mapped_object_id = lower(g)
                                                  inner join user_group u
                                                             on u.user_group_id = ugm.group_id
                                         union
                                         select distinct ugm.group_id
                                         from unnest(__provider_roles) r
                                                  inner join public.user_group_mapping ugm
                                                             on ugm.provider_code = _provider_code and ugm.mapped_role = lower(r)
                                                  inner join user_group u
                                                             on u.user_group_id = ugm.group_id)
                returning group_id)
       , affected_group_tenants as (
        insert
            into user_group_member (created_by, user_id, group_id, mapping_id, manual_assignment)
                select distinct _created_by, _target_user_id, ugm.group_id, ugm.ug_mapping_id, false
                from unnest(__provider_groups) g
                         inner join public.user_group_mapping ugm
                                    on ugm.provider_code = _provider_code and ugm.mapped_object_id = lower(g)
                where ugm.group_id not in (select group_id from user_group_member where user_id = _target_user_id)
                returning group_id)
       , affected_role_tenants as (
        insert
            into user_group_member (created_by, user_id, group_id, mapping_id, manual_assignment)
                select distinct _created_by, _target_user_id, ugm.group_id, ugm.ug_mapping_id, false
                from unnest(__provider_roles) r
                         inner join public.user_group_mapping ugm
                                    on ugm.provider_code = _provider_code and ugm.mapped_role = lower(r)
                where ugm.group_id not in (select group_id from user_group_member where user_id = _target_user_id)
                returning group_id)
       , all_group_ids as (select group_id
                           from affected_deleted_group_tenants
                           union
                           select group_id
                           from affected_group_tenants
                           union
                           select group_id
                           from affected_role_tenants)
       , all_tenants as (select tenant_id
                         from all_group_ids ids
                                  inner join user_group ug
                                             on ids.group_id = ug.user_group_id
                         group by tenant_id)
-- variable not really used, it's there just to avoid 'query has no destination for result data'
    select at.tenant_id
    from all_tenants at,
         lateral unsecure.clear_permission_cache(_created_by, at.tenant_id, _target_user_id) r
    into __not_really_used;

    return query
        select array_agg(distinct ug.code)
        from user_group_member ugm
                 inner join user_group ug on ug.user_group_id = ugm.group_id
        where user_id = _target_user_id;
end;
$$;

create function unsecure.recalculate_user_permissions(_created_by text, _tenant_id int, _target_user_id bigint)
    returns table
            (
                __groups      text[],
                __permissions text[]
            )
    language plpgsql
as
$$
declare
    __perm_cache_timeout_in_s bigint;
    __gs                      text[];
    __ps                      text[];
    __expiration_date         timestamptz;
begin

    if exists(select
              from auth.user_permission_cache
              where tenant_id = _tenant_id
                and user_id = _target_user_id
                and expiration_date > now()) then

        return query
            select upc.groups,
                   upc.permissions
            from auth.user_permission_cache upc
            where upc.tenant_id = _tenant_id
              and upc.user_id = _target_user_id;
    else
        select number_value
        from const.sys_param sp
        where sp.group_code = 'auth'
          and sp.code = 'perm_cache_timeout_in_s'
        into __perm_cache_timeout_in_s;

        if
            (__perm_cache_timeout_in_s is null) then
            __perm_cache_timeout_in_s := 300;
        end if;

        with ugs as (select user_group_id, group_code
                     from user_group_members
                     where (tenant_id = _tenant_id or tenant_id is null)
                       and user_id = _target_user_id),
             group_assignments as (select distinct ep.permission_code as full_code
                                   from ugs ug
                                            inner join auth.permission_assignment pa
                                                       on ug.user_group_id = pa.group_id
                                            inner join auth.effective_permissions ep on pa.perm_set_id = ep.perm_set_id
                                   where ep.perm_set_is_assignable = true
                                     and ep.permission_is_assignable = true
                                   union
                                   select distinct sp.full_code
                                   from ugs ug
                                            inner join auth.permission_assignment pa
                                                       on ug.user_group_id = pa.group_id
                                            inner join auth.permission p on pa.permission_id = p.permission_id
                                            inner join auth.permission sp
                                                       on sp.node_path <@ p.node_path and sp.is_assignable = true),
             user_assignments as (select distinct ep.permission_code as full_code
                                  from auth.permission_assignment pa
                                           inner join auth.effective_permissions ep
                                                      on pa.perm_set_id = ep.perm_set_id
                                  where (pa.tenant_id = _tenant_id
                                      or pa.tenant_id is null)
                                    and pa.user_id = _target_user_id
                                    and ep.perm_set_is_assignable = true
                                    and ep.permission_is_assignable = true
                                  union
                                  select distinct sp.full_code
                                  from auth.permission_assignment pa
                                           inner join auth.permission p
                                                      on pa.permission_id = p.permission_id
                                           inner join auth.permission sp
                                                      on sp.node_path <@ p.node_path and sp.is_assignable = true
                                  where (pa.tenant_id = _tenant_id
                                      or pa.tenant_id is null)
                                    and pa.user_id = _target_user_id)
                ,
             user_permissions as (select distinct full_code
                                  from group_assignments
                                  union
                                  select full_code
                                  from user_assignments
                                  order by full_code)
        select coalesce(array_agg(distinct ugs.group_code), array []::text[])                   rs,
               coalesce(array_agg(distinct user_permissions.full_code::text), array []::text[]) ps
        from ugs,
             user_permissions
        into __gs, __ps;

        __expiration_date := now() + interval '1 second' * __perm_cache_timeout_in_s;

        if
            not exists(select from auth.user_permission_cache upc where upc.user_id = _target_user_id) then
            insert into auth.user_permission_cache (created_by, user_id, tenant_id, groups, permissions, expiration_date)
            values (_created_by, _target_user_id, _tenant_id, __gs, __ps, __expiration_date);
        else
            update auth.user_permission_cache upc
            set modified        = now(),
                modified_by     = _created_by,
                groups          = __gs,
                permissions     = __ps,
                expiration_date = __expiration_date
            where tenant_id = _tenant_id
              and user_id = _target_user_id;
        end if;

        return query
            select __gs, __ps;
    end if;
end;
$$;

create function auth.has_owner(_tenant_id int, _user_group_id int default null)
    returns bool
    language plpgsql
    immutable
as
$$
begin
    if exists(select from owner where tenant_id = _tenant_id and user_group_id = _user_group_id) then
        return true;
    end if;

    return false;
end;
$$;

create function auth.is_owner(_user_id bigint, _tenant_id int, _user_group_id int default null)
    returns bool
    language plpgsql
    immutable
as
$$
begin
    if exists(select
              from owner
              where user_id = _user_id
                and tenant_id = _tenant_id
                and user_group_id = _user_group_id) then
        return true;
    end if;

    return false;
end;
$$;

create function auth.is_group_member(_user_id bigint, _tenant_id int, _user_group_id int default null)
    returns bool
    language plpgsql
    immutable
as
$$
begin
    if exists(select
              from user_group_members
              where user_id = _user_id
                and tenant_id = _tenant_id
                and user_group_id = _user_group_id) then
        return true;
    end if;

    return false;
end;
$$;

create function auth.can_manage_user_group(_user_id bigint, _tenant_id int, _user_group_id int, _permission text) returns bool
    language plpgsql
    immutable
as
$$
declare
    __can_members_manage_others bool;
    __has_owner                 bool;
    __is_member                 bool;
begin
    select can_members_manage_others, member_id is not null
    from user_group ug
             left join user_group_member ugm on ug.user_group_id = ugm.group_id
    where user_group_id = _user_group_id
      and ugm.user_id = _user_id
    into __can_members_manage_others, __is_member;

    if not (__can_members_manage_others and __is_member) then
        __has_owner := auth.has_owner(_tenant_id, _user_group_id);

        if not (auth.is_owner(_user_id, _tenant_id)) then
            if __has_owner then
                -- if user group has owner and user is not one of them throw 52281 exception
                if not auth.is_owner(_user_id, _tenant_id, _user_group_id) then
                    perform error.raise_52281(_user_id, _tenant_id, _user_group_id);
                end if;
            else
                -- when there is no owner anybody with the right permission can add new members
                perform auth.has_permission(_tenant_id, _user_id, _permission);
            end if;
        end if;
    end if;

    return true;
end;
$$;

create function auth.has_permissions(_tenant_id int, _target_user_id bigint, _perm_codes text[],
                                     _throw_err bool default true)
    returns bool
    language plpgsql
    stable
as
$$
declare
    __perms                   text[];
    __expiration_date         timestamptz;
    __last_used_provider_code text;
begin

    if (_target_user_id = 1) then
        return true;
    end if;

    select permissions, expiration_date
    from auth.user_permission_cache upc
    where upc.tenant_id = _tenant_id
       or upc.tenant_id = 1 -- primary/master tenant
        and user_id = _target_user_id
    into __perms, __expiration_date;

    if __expiration_date is null or __expiration_date <= now() then
        raise notice '__expiration_date=%', __expiration_date;

        if not exists(select from user_info ui where ui.user_id = _target_user_id) then
            perform error.raise_52103(_target_user_id);
        end if;

        select last_used_provider_code
        from user_info
        where user_id = _target_user_id
        into __last_used_provider_code;

        perform unsecure.recalculate_user_groups('permission_check'
            , _target_user_id
            , __last_used_provider_code
            );

        select __permissions
        from unsecure.recalculate_user_permissions('permission_check', _tenant_id, _target_user_id)
        into __perms;

    end if;

    if exists(
            select
            from unnest(__perms) p
                     inner join unnest(_perm_codes) rp on p = rp
        ) then
        return true;
    end if;

    --     if exists(
--             select p.code, ugm.user_id, p.node_path
--             from user_group ug
--                      inner join permission_assignment uga
--                                 on ug.user_group_id = uga.group_id and ug.tenant_id = _tenant_id
--                      inner join user_group_member ugm on ugm.group_id = uga.group_id
--                      inner join auth.perm_set ps on ps.perm_set_id = uga.perm_set_id
--                      inner join auth.perm_set_perm psp on ps.perm_set_id = psp.perm_set_id
--                      inner join auth.permission p on p.permission_id = psp.permission_id
--                      inner join (select unnest as code from unnest(_perm_codes)) pc
--                                 on p.full_code @> ext.text2ltree(pc.code)
--             where (ug.tenant_id = _tenant_id or ug.tenant_id is null)
--               and ugm.user_id = _target_user_id
--         ) then
--         return true;
--     end if;

    if (_throw_err) then

        perform add_journal_msg('system', _tenant_id, _target_user_id
            , format('User: (id: %s) has no permission: %s'
                                    , _target_user_id, array_to_string(_perm_codes, '; '))
            , 'perm', _target_user_id
            , _event_id := 50003);

        perform
            auth.throw_no_permission(_tenant_id, _target_user_id, _perm_codes);
    end if;

    return false;
end ;
$$;

create function auth.has_permission(_tenant_id int, _target_user_id bigint, _perm_code text,
                                    _throw_err bool default true)
    returns bool
    language plpgsql
    stable
as
$$
begin
    return auth.has_permissions(_tenant_id, _target_user_id, array [_perm_code], _throw_err);
end ;
$$;


create function unsecure.create_primary_tenant()
    returns setof tenant
    language sql
    rows 1
as
$$
insert into tenant(created_by, modified_by, title, code, is_removable, is_assignable)
values ('initial_script', 'initial_script', 'Primary', 'primary', false, true)
returning *;
$$;


create function unsecure.create_system_user()
    returns setof user_info
    language sql
    rows 1
as
$$
insert into user_info(created_by, modified_by, can_login, email, display_name, username)
values ('initial_script', 'initial_script', false, 'system', 'System', 'system')
returning *;

$$;

create function unsecure.delete_user_by_username_as_system(_username text)
    returns user_info
    language sql as
$$
delete
from user_info
where lower(username) = lower(_username)
returning *;

$$;

create function auth.validate_provider_is_active(_provider_code text)
    returns void
    language plpgsql
as
$$
begin
    if
        exists(select from auth.provider where code = _provider_code and is_active = false) then
        perform error.raise_52107(_provider_code);


    end if;
end;
$$;


/***
 *    ██████╗ ██████╗  ██████╗ ██╗   ██╗██╗██████╗ ███████╗██████╗ ███████╗
 *    ██╔══██╗██╔══██╗██╔═══██╗██║   ██║██║██╔══██╗██╔════╝██╔══██╗██╔════╝
 *    ██████╔╝██████╔╝██║   ██║██║   ██║██║██║  ██║█████╗  ██████╔╝███████╗
 *    ██╔═══╝ ██╔══██╗██║   ██║╚██╗ ██╔╝██║██║  ██║██╔══╝  ██╔══██╗╚════██║
 *    ██║     ██║  ██║╚██████╔╝ ╚████╔╝ ██║██████╔╝███████╗██║  ██║███████║
 *    ╚═╝     ╚═╝  ╚═╝ ╚═════╝   ╚═══╝  ╚═╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚══════╝
 *
 */

create function auth.create_provider(_created_by text, _user_id bigint, _provider_code text, _provider_name text,
                                     _is_active bool default true)
    returns table
            (
                __provider_id int
            )
    language plpgsql
    rows 1
as
$$
declare
    __last_id int;
begin

    perform
        auth.has_permission(null, _user_id, 'system.providers.create_provider');

    insert into auth.provider (created_by, modified_by, code, name, is_active)
    values (_created_by, _created_by, _provider_code, _provider_name, _is_active)
    returning provider_id
        into __last_id;

    return query
        select __last_id;

    perform
        add_journal_msg(_created_by, null, _user_id
            , format('User: %s created new authentication provider: %s'
                            , _created_by, _provider_name)
            , 'provider', __last_id
            , array ['provider_code', _provider_code, 'provider_name', _provider_name, 'is_active', _is_active::text]
            , 50011);
end;
$$;

create function auth.update_provider(_modified_by text, _user_id bigint, _provider_id int, _provider_code text,
                                     _provider_name text,
                                     _is_active bool default true)
    returns table
            (
                __provider_id int
            )
    language plpgsql
    rows 1
as
$$
declare
begin

    perform
        auth.has_permission(null, _user_id, 'system.providers.update_provider');

    return query
        update auth.provider
            set modified = now(),
                modified_by = _modified_by, code = _provider_code, name = _provider_name, is_active = _is_active
            where provider_id = _provider_id
            returning provider_id;

    perform
        add_journal_msg(_modified_by, null, _user_id
            , format('User: %s updated authentication provider: %s'
                            , _modified_by, _provider_name)
            , 'provider', _provider_id
            , array ['provider_code', _provider_code, 'provider_name', _provider_name, 'is_active', _is_active::text]
            , 50012);
end;
$$;

create function auth.delete_provider(_deleted_by text, _user_id bigint, _provider_code text)
    returns table
            (
                __user_id      bigint,
                __username     text,
                __display_name text
            )
    language plpgsql
    rows 1
as
$$
declare
    __provider_id int;
begin

    perform
        auth.has_permission(null, _user_id, 'system.providers.delete_provider');

    return query
        delete
            from auth.provider
                where code = _provider_code
                returning __provider_id;

    perform
        add_journal_msg(_deleted_by, null, _user_id
            , format('User: %s deleted authentication provider: %s'
                            , _deleted_by, _provider_code)
            , 'provider', __provider_id
            , null
            , 50013);
end;
$$;

create function auth.get_provider_users(_requested_by text, _user_id bigint, _provider_code text)
    returns table
            (
                __user_id          bigint,
                __user_identity_id bigint,
                __username         text,
                __display_name     text
            )
    language plpgsql
as
$$
declare
    __provider_id int;
begin
    perform
        auth.has_permission(null, _user_id, 'system.manage_provider.get_users');

    select provider_id
    from auth.provider
    where code = _provider_code
    into __provider_id;

    return query
        select ui.user_id, uid.user_identity_id, ui.username, ui.display_name
        from user_identity uid
                 inner join user_info ui on uid.user_id = ui.user_id
        where uid.provider_code = _provider_code
        order by ui.display_name;

    perform
        add_journal_msg(_requested_by, null, _user_id
            , format('User: %s requested a list of all users for authentication provider: %s'
                            , _requested_by, _provider_code)
            , 'provider', __provider_id
            , null
            , 50016);
end;
$$;

create function auth.enable_provider(_modified_by text, _user_id bigint, _provider_code text)
    returns table
            (
                __provider_id int
            )
    language plpgsql
    rows 1
as
$$
declare
    __provider_id int;
begin

    perform
        auth.has_permission(null, _user_id, 'system.providers.update_provider');

    return query
        update auth.provider
            set is_active = true
            where code = _provider_code
            returning provider_id;

    perform
        add_journal_msg(_modified_by, null, _user_id
            , format('User: %s enabled authentication provider: %s'
                            , _modified_by, _provider_code)
            , 'provider', __provider_id
            , null
            , 50014);
end;
$$;

create function auth.disable_provider(_modified_by text, _user_id bigint, _provider_code text)
    returns table
            (
                __provider_id int
            )
    language plpgsql
    rows 1
as
$$
declare
    __provider_id int;
begin

    perform
        auth.has_permission(null, _user_id, 'system.providers.update_provider');

    return query
        update auth.provider
            set is_active = false
            where code = _provider_code
            returning provider_id;

    perform
        add_journal_msg(_modified_by, null, _user_id
            , format('User: %s disabled authentication provider: %s'
                            , _modified_by, _provider_code)
            , 'provider', __provider_id
            , null
            , 50015);
end;
$$;


/***
 *     █████╗ ██╗   ██╗████████╗██╗  ██╗    ███████╗██╗   ██╗███████╗███╗   ██╗████████╗███████╗
 *    ██╔══██╗██║   ██║╚══██╔══╝██║  ██║    ██╔════╝██║   ██║██╔════╝████╗  ██║╚══██╔══╝██╔════╝
 *    ███████║██║   ██║   ██║   ███████║    █████╗  ██║   ██║█████╗  ██╔██╗ ██║   ██║   ███████╗
 *    ██╔══██║██║   ██║   ██║   ██╔══██║    ██╔══╝  ╚██╗ ██╔╝██╔══╝  ██║╚██╗██║   ██║   ╚════██║
 *    ██║  ██║╚██████╔╝   ██║   ██║  ██║    ███████╗ ╚████╔╝ ███████╗██║ ╚████║   ██║   ███████║
 *    ╚═╝  ╚═╝ ╚═════╝    ╚═╝   ╚═╝  ╚═╝    ╚══════╝  ╚═══╝  ╚══════╝╚═╝  ╚═══╝   ╚═╝   ╚══════╝
 *
 */

create function unsecure.create_auth_event(_created_by text, _user_id bigint, _event_type_code text,
                                           _target_user_id bigint, _ip_address text, _user_agent text, _origin text)
    returns table
            (
                __auth_event_id bigint
            )
    language plpgsql
as
$$
declare
    __requester_username text;
    __target_username    text;
begin
    --     perform auth.has_permission(null, _user_id, 'system.authentication.create_auth_event');

    if
        _user_id is not null and (__requester_username is null or __requester_username = '') then
        select username
        from user_info ui
        where ui.user_id = _user_id
        into __requester_username;
    end if;

    if
        _target_user_id is not null then
        select username
        from user_info ui
        where ui.user_id = _target_user_id
        into __target_username;
    end if;

    return query insert into auth.auth_event (created_by,
                                              event_type_code,
                                              requester_user_id,
                                              requester_username,
                                              target_user_id,
                                              target_username,
                                              ip_address,
                                              user_agent,
                                              origin)
        values (_created_by,
                _event_type_code,
                _user_id,
                __requester_username,
                _target_user_id,
                __target_username,
                _ip_address,
                _user_agent,
                _origin)
        returning auth_event_id;
end;
$$;


create function auth.create_auth_event(_created_by text, _user_id bigint, _event_type_code text,
                                       _target_user_id bigint, _ip_address text, _user_agent text, _origin text)
    returns table
            (
                ___auth_event_id bigint
            )
    language plpgsql
as
$$
begin
    return query
        select __auth_event_id
        from unsecure.create_auth_event(_created_by, _user_id, _event_type_code, _target_user_id, _ip_address,
                                        _user_agent, _origin);
end;
$$;

/***
 *    ████████╗ ██████╗ ██╗  ██╗███████╗███╗   ██╗███████╗
 *    ╚══██╔══╝██╔═══██╗██║ ██╔╝██╔════╝████╗  ██║██╔════╝
 *       ██║   ██║   ██║█████╔╝ █████╗  ██╔██╗ ██║███████╗
 *       ██║   ██║   ██║██╔═██╗ ██╔══╝  ██║╚██╗██║╚════██║
 *       ██║   ╚██████╔╝██║  ██╗███████╗██║ ╚████║███████║
 *       ╚═╝    ╚═════╝ ╚═╝  ╚═╝╚══════╝╚═╝  ╚═══╝╚══════╝
 *
 */

create function unsecure.expire_tokens(_created_by text)
    returns void
    language sql as
$$
update auth.token
set modified         = now(),
    modified_by      = _created_by,
    token_state_code = 'expired'
where token_state_code = 'valid'
  and expires_at
    < now();
$$;


create function auth.create_token(_created_by text, _user_id bigint,
                                  _target_user_id bigint,
                                  _auth_event_id int,
                                  _token_type_code text,
                                  _token_channel_code text,
                                  _token text,
                                  _expires_at timestamptz default null)
    returns table
            (
                ___token_id   bigint,
                ___token_uid  text,
                ___expires_at timestamptz
            )
    language plpgsql
as
$$
declare
    __default_expiration_in_seconds int;
    __last_id                       bigint;
    __token_uid                     text;
    __token_expires_at              timestamptz;
begin
    perform
        auth.has_permission(null, _user_id, 'system.tokens.create_token');

    if
        _expires_at is null then

        select default_expiration_in_seconds
        from const.token_type
        where code = _token_type_code
        into __default_expiration_in_seconds;

        _expires_at := now() + '1 second'::interval * __default_expiration_in_seconds;
    end if;

    if
        _target_user_id is not null then
        -- invalidate all previous tokens of the same type for the same user that are still valid
        update auth.token
        set modified         = now(),
            modified_by      = _created_by,
            token_state_code = 'invalid'
        where user_id = _target_user_id
          and token_type_code = _token_type_code
          and token_state_code = 'valid';
    end if;

    if
        exists(select
               from auth.token
               where token = _token
                 and token_state_code = 'valid'
                 and token_type_code = _token_type_code) then
        perform error.raise_52276();
    end if;


    insert into auth.token (created_by,
                            user_id, auth_event_id, token_type_code, token_channel_code,
                            token, expires_at)
    values (_created_by,
            _target_user_id,
            _auth_event_id,
            _token_type_code,
            _token_channel_code,
            _token,
            _expires_at)
    returning token_id, uid, expires_at
        into __last_id, __token_uid, __token_expires_at;

    perform
        add_journal_msg(_created_by, null, _user_id
            , format('User: %s created a new token for user: %s'
                            , _created_by, _target_user_id)
            , case when _target_user_id is not null then 'user' else 'token' end
            , case when _target_user_id is not null then _target_user_id else __last_id end
            ,
                        array ['token_type_code', _token_type_code, 'token_channel_code', _token_channel_code, 'token_expires_at', _expires_at::text]
            , 50401);

    return query
        select __last_id, __token_uid, __token_expires_at;

    perform unsecure.expire_tokens(_created_by);
end;
$$;

create function auth.validate_token(_modified_by text, _user_id bigint,
                                    _target_user_id bigint,
                                    _token text,
                                    _ip_address text,
                                    _user_agent text,
                                    _origin text,
                                    _set_as_used bool default false)
    returns table
            (
                ___token_id         bigint,
                ___token_uid        text,
                ___token_state_code text,
                ___used_at          timestamptz,
                ___user_id          bigint
            )
    language plpgsql
as
$$
declare
    __token_id         bigint;
    __token_uid        text;
    __token_state_code text;
    __token_user_id    bigint;
begin
    perform
        auth.has_permission(null, _user_id, 'system.tokens.validate_token');

    select token_id, uid, token_state_code, user_id
    from auth.token
    where token = _token
      and ((_target_user_id is not null and token.user_id = _target_user_id) or true)
    into __token_id, __token_uid, __token_state_code, __token_user_id;

    if
        __token_id is null then
        perform error.raise_52277();
    end if;

    if
        __token_state_code <> 'valid' then
        perform error.raise_52278(__token_uid);
    end if;

    if
        _target_user_id is not null and _target_user_id <> __token_user_id then
        perform error.raise_52279(__token_uid);
    end if;

    perform
        add_journal_msg(_modified_by, null, _user_id
            , format('User: %s validated a token for user: %s'
                            , _modified_by, _target_user_id)
            , case when _target_user_id is not null then 'user' else 'token' end
            , case when _target_user_id is not null then _target_user_id else __token_id end
            ,
                        array ['ip_address', _ip_address, 'user_agent', _user_agent, 'origin', _origin]
            , 50402);


    if
        _set_as_used then
        return query
            select used_token.__token_id,
                   used_token.__token_uid,
                   used_token.__token_state_code,
                   used_token.__used_at,
                   used_token.__user_id
            from auth.set_token_as_used(_modified_by, _user_id, __token_id, _ip_address, _user_agent,
                                        _origin) used_token;
    else
        return query
            select token_id, uid, token_state_code, used_at, user_id
            from auth.token
            where token_id = __token_id;
    end if;


    perform unsecure.expire_tokens(_modified_by);
end;
$$;

create
    or replace function auth.set_token_as_used(_modified_by text, _user_id bigint, _token_id bigint,
                                               _ip_address text,
                                               _user_agent text,
                                               _origin text)
    returns table
            (
                __token_id         bigint,
                __token_uid        text,
                __token_state_code text,
                __used_at          timestamptz,
                __user_id          bigint
            )
    language plpgsql
as
$$
begin

    perform
        auth.has_permission(null, _user_id, 'system.tokens.set_as_used');

    if
        not exists(select from token where token_id = _token_id and token_state_code = 'valid') then
        perform error.raise_52278(_token_id);
    end if;

    return query
        update token
            set modified_by = _modified_by, modified = now(), token_state_code = 'used', used_at = now(), ip_address = _ip_address, user_agent = _user_agent, origin = _origin
            where token_id = _token_id
            returning token_id
                , uid
                , token_state_code
                , used_at
                , user_id;

    perform
        add_journal_msg(_modified_by, null, _user_id
            , format('User: %s set token (id: %s) as used'
                            , _modified_by, _token_id)
            , 'token'
            , _token_id
            , array ['ip_address', _ip_address, 'user_agent', _user_agent, 'origin', _origin]
            , _event_id := 50403);

end;
$$;


/***
 *     ██████╗ ██████╗  ██████╗ ██╗   ██╗██████╗ ███████╗
 *    ██╔════╝ ██╔══██╗██╔═══██╗██║   ██║██╔══██╗██╔════╝
 *    ██║  ███╗██████╔╝██║   ██║██║   ██║██████╔╝███████╗
 *    ██║   ██║██╔══██╗██║   ██║██║   ██║██╔═══╝ ╚════██║
 *    ╚██████╔╝██║  ██║╚██████╔╝╚██████╔╝██║     ███████║
 *     ╚═════╝ ╚═╝  ╚═╝ ╚═════╝  ╚═════╝ ╚═╝     ╚══════╝
 *
 */


create function public.assign_tenant_owner(_created_by text, _user_id bigint, _tenant_id int, _target_user_id bigint)
    returns setof user_group_member
    language plpgsql
    rows 1
as
$$
declare
    __ug_id int;
begin
    perform
        auth.has_permission(1, _user_id, 'system.manage_tenants.assign_owner');

    select ug.user_group_id
    from user_group ug
    where ug.tenant_id = _tenant_id
      and ug.code = 'tenant_owners'
    into __ug_id;

    return query
        select ugm.*
        from unsecure.create_user_group_member(_created_by, _user_id
                 , _tenant_id, __ug_id, _target_user_id) r
                 inner join user_group_member ugm on ugm.member_id = r.__user_group_member_id;

    perform
        add_journal_msg(_created_by, _tenant_id, _user_id
            , format('User: %s assigned new owner: %s to tenant: %s'
                            , _created_by, _target_user_id, _tenant_id)
            , 'tenant', _tenant_id
            , array ['target_user_id', _target_user_id::text]
            , 50004);
end;
$$;

create function unsecure.create_user_group(_created_by text, _user_id bigint, _title text
    , _tenant_id int default null, _is_assignable bool default true, _is_active bool default true,
                                           _is_external bool default false,
                                           _is_system bool default false, _is_default bool default false)
    returns table
            (
                __group_id int
            )
    language plpgsql
    rows 1
as
$$
declare
    __last_id int;
begin

    insert into user_group (created_by, modified_by, tenant_id, title, is_default, is_system, is_assignable,
                            is_active, is_external)
    values (_created_by, _created_by, _tenant_id, _title, _is_default, _is_system, _is_assignable, _is_active,
            _is_external)
    returning user_group_id
        into __last_id;

    return query
        select __last_id;

    perform
        add_journal_msg(_created_by, _tenant_id, _user_id
            , format('User: %s added new group: %s in tenant: %s'
                            , _created_by, _title, _tenant_id)
            , 'group', __last_id
            ,
                        array ['title', _title, 'is_default', _is_default::text
                            , 'is_system', _is_system::text
                            , 'is_assignable', _is_assignable::text
                            , 'is_active', _is_active::text]
            , 50201);

end ;
$$;

create function unsecure.create_user_group_as_system(_tenant_id int, _title text
, _is_system bool default false, _is_assignable bool default true)
    returns setof user_group
    language sql
    rows 1
as
$$
select ug.*
from unsecure.create_user_group('system', 1, _title, _tenant_id, _is_assignable, true, false, _is_system) g
         inner join user_group ug on ug.user_group_id = g.__group_id;

$$;

create function auth.create_user_group(_created_by text, _user_id bigint, _title text, _tenant_id int,
                                       _is_assignable bool default true, _is_active bool default true,
                                       _is_external bool default false, _is_default bool default false)
    returns table
            (
                __group_id int
            )
    language plpgsql
    rows 1
as
$$
begin
    perform
        auth.has_permissions(_tenant_id, _user_id,
                             array ['system.manage_groups.create_group']);

    return query
        select *
        from unsecure.create_user_group(_created_by, _user_id, _title, _tenant_id
            , _is_assignable, _is_active, _is_external, false,
                                        _is_default);
end ;
$$;

create function auth.update_user_group(_modified_by text, _user_id bigint, _tenant_id int, _ug_id int, _title text,
                                       _is_assignable bool, _is_active bool, _is_external bool, _is_default bool)
    returns table
            (
                __group_id int
            )
    language plpgsql
    rows 1
as
$$
begin
    perform
        auth.has_permission(_tenant_id, _user_id, 'system.manage_groups.update_group');

    return query
        update user_group
            set modified_by = _modified_by
                , modified = now()
                , title = _title
                , is_assignable = _is_assignable
                , is_active = _is_active
                , is_external = _is_external
                , is_default = _is_default
            where tenant_id = _tenant_id
                and user_group_id = _ug_id
            returning user_group_id;
end;
$$;

create function auth.enable_user_group(_modified_by text, _user_id bigint, _tenant_id int, _user_group_id int)
    returns table
            (
                __group_id      int,
                __is_active     bool,
                __is_assignable bool,
                __modified      timestamptz,
                __modified_by   text
            )
    language plpgsql
    rows 1
as
$$
begin
    perform
        auth.has_permission(_tenant_id, _user_id, 'system.manage_groups.update_group');

    return query
        update user_group
            set modified_by = _modified_by
                , modified = now()
                , is_active = true
            where tenant_id = _tenant_id
                and user_group_id = _user_group_id
            returning user_group_id
                , is_active
                , is_assignable
                , modified
                , modified_by;

    perform
        add_journal_msg(_modified_by, _tenant_id, _user_id
            , format('User: %s enabled user group: %s in tenant: %s'
                            , _modified_by, _user_group_id, _tenant_id)
            , 'group', _user_group_id
            , null
            , 50204);
end;
$$;

create function auth.disable_user_group(_modified_by text, _user_id bigint, _tenant_id int, _user_group_id int)
    returns table
            (
                __group_id      int,
                __is_active     bool,
                __is_assignable bool,
                __modified      timestamptz,
                __modified_by   text
            )
    language plpgsql
    rows 1
as
$$
begin
    perform
        auth.has_permission(_tenant_id, _user_id, 'system.manage_groups.update_group');

    return query
        update user_group
            set modified_by = _modified_by
                , modified = now()
                , is_active = false
            where tenant_id = _tenant_id
                and user_group_id = _user_group_id
            returning user_group_id
                , is_active
                , is_assignable
                , modified
                , modified_by;

    perform
        add_journal_msg(_modified_by, _tenant_id, _user_id
            , format('User: %s disabled user group: %s in tenant: %s'
                            , _modified_by, _user_group_id, _tenant_id)
            , 'group', _user_group_id
            , null
            , 50205);
end;
$$;

create function auth.lock_user_group(_modified_by text, _user_id bigint, _tenant_id int, _user_group_id int)
    returns table
            (
                __group_id      int,
                __is_active     bool,
                __is_assignable bool,
                __modified      timestamptz,
                __modified_by   text
            )
    language plpgsql
    rows 1
as
$$
begin
    perform
        auth.has_permission(_tenant_id, _user_id, 'system.manage_groups.lock_group');

    return query
        update user_group
            set modified_by = _modified_by
                , modified = now()
                , is_assignable = false
            where tenant_id = _tenant_id
                and user_group_id = _user_group_id
            returning user_group_id
                , is_active
                , is_assignable
                , modified
                , modified_by;

    perform
        add_journal_msg(_modified_by, _tenant_id, _user_id
            , format('User: %s enabled user group: %s in tenant: %s'
                            , _modified_by, _user_group_id, _tenant_id)
            , 'group', _user_group_id
            , null
            , 50207);
end;
$$;

create function auth.unlock_user_group(_modified_by text, _user_id bigint, _tenant_id int, _user_group_id int)
    returns table
            (
                __group_id      int,
                __is_active     bool,
                __is_assignable bool,
                __modified      timestamptz,
                __modified_by   text
            )
    language plpgsql
    rows 1
as
$$
begin
    perform
        auth.has_permission(_tenant_id, _user_id, 'system.manage_groups.update_group');

    return query
        update user_group
            set modified_by = _modified_by
                , modified = now()
                , is_assignable = true
            where tenant_id = _tenant_id
                and user_group_id = _user_group_id
            returning user_group_id
                , is_active
                , is_assignable
                , modified
                , modified_by;

    perform
        add_journal_msg(_modified_by, _tenant_id, _user_id
            , format('User: %s disabled user group: %s in tenant: %s'
                            , _modified_by, _user_group_id, _tenant_id)
            , 'group', _user_group_id
            , null
            , 50206);
end;
$$;

create function auth.delete_user_group(_deleted_by text, _user_id bigint, _tenant_id int, _user_group_id int)
    returns table
            (
                __user_group_id int
            )
    language plpgsql
    rows 1
as
$$
declare
    __is_system bool;
begin

    perform
        auth.has_permission(_tenant_id, _user_id, 'system.manage_groups.delete_group');

    select is_system, tenant_id
    from user_group ug
    where ug.user_group_id = _user_group_id
    into __is_system;

    if
        __is_system is null then
        perform error.raise_52171(_user_group_id);
    end if;

    if
        __is_system then
        perform error.raise_52271(_user_group_id);
    end if;

    return query
        delete
            from user_group
                where tenant_id = _tenant_id
                    and user_group_id = _user_group_id
                returning user_group_id;

    perform
        add_journal_msg(_deleted_by, _tenant_id, _user_id
            , format('User: %s removed user group: %s in tenant: %s'
                            , _deleted_by, _user_group_id, _tenant_id)
            , 'group', _user_group_id
            , null
            , 50203);
end;
$$;


create function unsecure.create_user_group_member(_created_by text, _user_id bigint, _tenant_id int, _user_group_id int,
                                                  _target_user_id bigint)
    returns table
            (
                __user_group_member_id bigint
            )
    language plpgsql
    rows 1
as
$$
declare
    __is_assignable bool;
    __is_external   bool;
    __is_active     bool;
begin

    select is_assignable, is_external, is_active
    from user_group ug
    where ug.user_group_id = _user_group_id
    into __is_assignable, __is_external, __is_active;

    if __is_active is null then
        perform error.raise_52171(_user_group_id);
    end if;

    if not __is_active then
        perform error.raise_52172(_user_group_id);
    end if;

    raise notice 'Is assignable: %, is external: %'
        , __is_assignable, __is_external;

    if not __is_assignable or __is_external then
        perform error.raise_52173(_user_group_id);
    end if;

    return query insert into user_group_member (created_by, group_id, user_id, manual_assignment)
        values (_created_by, _user_group_id, _target_user_id, true)
        returning member_id;

    perform
        add_journal_msg(_created_by, _tenant_id, _user_id
            , format('User: %s added new user: %s to group: %s in tenant: %s'
                            , _created_by, _target_user_id, _user_group_id, _tenant_id)
            , 'group', _user_group_id
            , array ['target_user_id', _target_user_id::text]
            , 50131);
end;
$$;

create function unsecure.create_user_group_member_as_system(_user_name text, _group_title text, _tenant_id int default null)
    returns setof user_group_member
    language plpgsql
as

$$
declare
    __user_id  bigint;
    __group_id int;
begin
    select ui.user_id
    from user_info ui
    where ui.username = _user_name
    into __user_id;

    select user_group_id
    from user_group ug
    where lower(ug.title) = lower(_group_title)
    into __group_id;

    return query
        select ugm.*
        from unsecure.create_user_group_member('system', 1, _tenant_id, __group_id, __user_id) r
                 inner join user_group_member ugm on ugm.member_id = r.__user_group_member_id;
end;
$$;

create function auth.create_user_group_member(_created_by text, _user_id bigint, _tenant_id int, _user_group_id int,
                                              _target_user_id int)
    returns table
            (
                __user_group_member_id bigint
            )
    language plpgsql
    rows 1
as
$$
begin
    perform auth.can_manage_user_group(_user_id, _tenant_id, _user_group_id, 'system.manage_groups.create_member');

    return query
        select *
        from unsecure.create_user_group_member(_created_by, _user_id, _tenant_id
            , _user_group_id, _target_user_id);
end;

$$;

create function auth.delete_user_group_member(_deleted_by text, _user_id bigint, _tenant_id int, _user_group_id int,
                                              _target_user_id bigint)
    returns void
    language plpgsql
as
$$
begin
    perform auth.can_manage_user_group(_user_id, _tenant_id, _user_group_id, 'system.manage_groups.delete_member');

    delete
    from user_group_member
    where group_id = _user_group_id
      and user_id = _target_user_id;

    perform
        add_journal_msg(_deleted_by, _tenant_id, _user_id
            , format('User: %s removed user: %s from group: %s in tenant: %s'
                            , _deleted_by, _target_user_id, _user_group_id, _tenant_id)
            , 'group', _user_group_id
            , array ['target_user_id', _target_user_id::text]
            , 50133);
end;
$$;

create function unsecure.get_user_group_members(_requested_by text, _user_id bigint, _tenant_id int,
                                                _user_group_id int)
    returns table
            (
                __created                    timestamptz,
                __created_by                 text,
                __member_id                  bigint,
                __manual_assignment          bool,
                __user_id                    bigint,
                __user_display_name          text,
                __user_is_system             bool,
                __user_is_active             bool,
                __user_is_locked             bool,
                __mapping_id                 int,
                __mapping_mapped_object_name text,
                __mapping_provider_code      text
            )
    language plpgsql
    rows 1
as
$$
begin

    if
        (not exists(select
                    from user_group
                    where user_group_id = _user_group_id
                      and (tenant_id = _tenant_id or _tenant_id is null))) then
        perform error.raise_52171(_user_group_id);
    end if;

    return query
        select ugm.created
             , ugm.created_by
             , ugm.member_id
             , ugm.manual_assignment
             , ugm.user_id
             , ui.display_name
             , ui.is_system
             , ui.is_active
             , ui.is_locked
             , ugm.mapping_id
             , ugma.mapped_object_name
             , ugma.provider_code
        from user_group_member ugm
                 left join user_group_mapping ugma on ugma.ug_mapping_id = ugm.mapping_id
                 inner join user_info ui on ui.user_id = ugm.user_id
        where ugm.group_id = _user_group_id;

    perform
        add_journal_msg(_requested_by, _tenant_id, _user_id
            , format('User: %s requested user group members: %s in tenant: %s'
                            , _requested_by, _user_group_id, _tenant_id)
            , 'group', _user_group_id
            , null
            , 50210);
end;
$$;

create function auth.get_user_group_members(_requested_by text, _user_id bigint, _tenant_id int, _user_group_id int)
    returns table
            (
                __created                    timestamptz,
                __created_by                 text,
                __member_id                  bigint,
                __manual_assignment          bool,
                __user_id                    bigint,
                __user_display_name          text,
                __user_is_system             bool,
                __user_is_active             bool,
                __user_is_locked             bool,
                __mapping_id                 int,
                __mapping_mapped_object_name text,
                __mapping_provider_code      text
            )
    language plpgsql
    rows 1
as
$$
begin
    perform
        auth.has_permission(_tenant_id, _user_id, 'system.manage_groups.get_members');

    return query
        select *
        from unsecure.get_user_group_members(_requested_by, _user_id
            , _tenant_id, _user_group_id);
end;
$$;

create function auth.create_user_group_mapping(_created_by text, _user_id bigint, _tenant_id int, _user_group_id int,
                                               _provider_code text,
                                               _mapped_object_id text default null,
                                               _mapped_object_name text default null,
                                               _mapped_role text default null)
    returns table
            (
                __ug_mapping_id int
            )
    language plpgsql
    rows 1
as
$$
declare
    __is_group_active bool;
begin

    if
        _mapped_object_id is null and _mapped_role is null then
        perform error.raise_52174();

    end if;

    perform
        auth.has_permission(_tenant_id, _user_id, 'system.manage_groups.create_mapping');

    select is_active, tenant_id
    from user_group ug
    where ug.user_group_id = _user_group_id
    into __is_group_active;

    if
        __is_group_active is null then
        perform error.raise_52171(_user_group_id);
    end if;

    return query insert into user_group_mapping (created_by, group_id, provider_code, mapped_object_id,
                                                 mapped_object_name,
                                                 mapped_role)
        values (_created_by, _user_group_id, _provider_code, lower(_mapped_object_id), _mapped_object_name,
                lower(_mapped_role))
        returning ug_mapping_id;


    with affected_users as (select user_id
                            from user_identity uid
                            where lower(_mapped_object_id) = any (provider_groups)
                               or lower(_mapped_object_id) = any (provider_roles))
    update auth.user_permission_cache
    set modified_by     = _created_by,
        modified        = now(),
        expiration_date = now() - '1 sec':: interval
    where user_id in (select user_id
                      from affected_users);


    perform
        add_journal_msg(_created_by, _tenant_id, _user_id
            , format('User: %s added new provider: %s mapping: %s to group: %s in tenant: %s'
                            , _created_by, _provider_code, coalesce(_mapped_object_id, _mapped_role),
                     _user_group_id, _tenant_id)
            , 'group', _user_group_id
            ,
                        array ['provider_code', _provider_code, 'mapped_object_id'
                            , _mapped_object_id::text, 'mapped_object_name'
                            , _mapped_object_name, '_mapped_role', _mapped_role]
            , 50231);
end;
$$;

create function auth.delete_user_group_mapping(_deleted_by text, _user_id bigint, _tenant_id int, _ug_mapping_id int)
    returns void
    language plpgsql
as
$$
declare
    __user_group_id      int;
    __provider_code      text;
    __mapped_object_id   text;
    __mapped_object_name text;
    __mapped_role        text;
begin
    perform
        auth.has_permission(_tenant_id, _user_id, 'system.manage_groups.delete_mapping');

    -- expire user_permission_cache for affected users
    with affected_users as (select user_id
                            from user_group_member ugm
                            where ugm.mapping_id = _ug_mapping_id)
    update auth.user_permission_cache
    set modified_by     = _deleted_by,
        modified        = now(),
        expiration_date = now() - '1 sec':: interval
    where user_id in (select user_id
                      from affected_users);

    delete
    from user_group_mapping
    where ug_mapping_id = _ug_mapping_id
    returning group_id, provider_code, mapped_object_id, mapped_object_name, mapped_role
        into __user_group_id, __provider_code, __mapped_object_id, __mapped_object_name, __mapped_role;


    perform
        add_journal_msg(_deleted_by, _tenant_id, _user_id
            , format('User: %s removed group mapping: %s from group: %s in tenant: %s'
                            , _deleted_by, __mapped_object_name, __user_group_id, _tenant_id)
            , 'group', __user_group_id
            ,
                        array ['provider_code', __provider_code, 'mapped_object_id'
                            , __mapped_object_id::text, 'mapped_object_name', __mapped_object_name, 'mapped_role', __mapped_role]
            , 50233);
end;
$$;

-- Creates a group with mapping that is locked so no members can be added manually
create function auth.create_external_user_group(_created_by text, _user_id bigint, _title text, _tenant_id int,
                                                _provider text,
                                                _is_assignable bool default true, _is_active bool default true,
                                                _mapped_object_id text default null,
                                                _mapped_object_name text default null,
                                                _mapped_role text default null)
    returns table
            (
                __group_id int
            )
    language plpgsql
    rows 1
as
$$
declare
    __last_id int;
begin
    perform
        auth.has_permissions(_tenant_id, _user_id,
                             array ['system.manage_groups.create_group']);


    select *
    from unsecure.create_user_group(_created_by, _user_id, _title, _tenant_id
        , _is_assignable, _is_active, true,
                                    false)
    into __last_id;

    perform
        auth.create_user_group_mapping(_created_by, _user_id, _tenant_id, __last_id, _provider, _mapped_object_id,
                                       _mapped_object_name, _mapped_role);

    return query
        select __last_id;
end ;
$$;

create function auth.set_user_group_as_external(_modified_by text, _user_id bigint, _tenant_id int, _user_group_id int)
    returns void
    language plpgsql
as
$$
begin
    perform
        auth.has_permission(_tenant_id, _user_id, 'system.manage_groups.update_group');

    delete
    from user_group_member ugm
    where ugm.group_id = _user_group_id
      and ugm.manual_assignment = true;

    update user_group
    set modified    = now(),
        modified_by = _modified_by,
        is_external = true
    where user_group_id = _user_group_id;


    perform
        add_journal_msg(_modified_by, _tenant_id, _user_id
            , format('User: %s set user group as external in tenant: %s'
                            , _modified_by, _user_group_id, _tenant_id)
            , 'group', _user_group_id
            , null
            , 50208);
end;
$$;

create function auth.set_user_group_as_hybrid(_modified_by text, _user_id bigint, _tenant_id int, _user_group_id int)
    returns void
    language plpgsql
as
$$
begin
    perform
        auth.has_permission(_tenant_id, _user_id, 'system.manage_groups.update_group');

    update user_group
    set modified    = now(),
        modified_by = _modified_by,
        is_external = false
    where user_group_id = _user_group_id;

    perform
        add_journal_msg(_modified_by, _tenant_id, _user_id
            , format('User: %s set user group as hybrid in tenant: %s'
                            , _modified_by, _user_group_id, _tenant_id)
            , 'group', _user_group_id
            , null
            , 50209);
end;
$$;

create function unsecure.get_user_group_by_id(_requested_by text, _user_id bigint, _tenant_id int,
                                              _user_group_id int)
    returns table
            (
                __user_group_id int,
                __tenant_id     int,
                __title         text,
                __code          text,
                __is_system     bool,
                __is_external   bool,
                __is_assignable bool,
                __is_active     bool,
                __is_default    bool
            )
    language plpgsql
as
$$
BEGIN
    return query select user_group_id
                      , tenant_id
                      , title
                      , code
                      , is_system
                      , is_external
                      , is_assignable
                      , is_active
                      , is_default
                 from user_group
                 where user_group_id = _user_group_id;

    perform
        add_journal_msg(_requested_by, _tenant_id, _user_id
            , format('User: %s requested group info: %s in tenant: %s'
                            , _requested_by, _user_group_id, _tenant_id)
            , 'group', _user_group_id
            , null
            , 50211);
end
$$;

create function auth.get_user_group_by_id(_requested_by text, _user_id bigint, _tenant_id int,
                                          _user_group_id int)
    returns table
            (
                __user_group_id int,
                __tenant_id     int,
                __title         text,
                __code          text,
                __is_system     bool,
                __is_external   bool,
                __is_assignable bool,
                __is_active     bool,
                __is_default    bool
            )
    language plpgsql
as
$$
BEGIN
    perform
        auth.has_permission(_tenant_id, _user_id, 'system.manage_groups.get_group');

    return query
        select *
        from unsecure.get_user_group_by_id(_requested_by, _user_id, _tenant_id, _user_group_id);
end
$$;


/***
 *    ######## ######## ##    ##    ###    ##    ## ########  ######
 *       ##    ##       ###   ##   ## ##   ###   ##    ##    ##    ##
 *       ##    ##       ####  ##  ##   ##  ####  ##    ##    ##
 *       ##    ######   ## ## ## ##     ## ## ## ##    ##     ######
 *       ##    ##       ##  #### ######### ##  ####    ##          ##
 *       ##    ##       ##   ### ##     ## ##   ###    ##    ##    ##
 *       ##    ######## ##    ## ##     ## ##    ##    ##     ######
 */


create function public.create_tenant(_created_by text, _user_id bigint, _title text, _code text default null,
                                     _is_removable bool default true, _is_assignable bool default true,
                                     _tenant_owner_id bigint default null)
    returns setof tenant
    language plpgsql
    rows 1
as
$$
declare
    __last_id                int;
    __tenant_owner_group_id  int;
    __tenant_member_group_id int;
begin
    perform
        auth.has_permission(1, _user_id, 'system.manage_tenants.create_tenant');

    insert into tenant (created_by, modified_by, title, code, is_removable, is_assignable)
    values (_created_by, _created_by, _title, coalesce(_code, helpers.get_code(_title)), _is_removable,
            _is_assignable)
    returning tenant_id
        into __last_id;

    perform
        add_journal_msg(_created_by, __last_id, _user_id
            , format('User: %s created new tenant: %s'
                            , _created_by, _title)
            , 'tenant', __last_id
            , array ['title', _title]
            , 50001);

    select __group_id
    from unsecure.create_user_group(_created_by, _user_id, 'Tenant Admins'
        , __last_id, true, true, false, true)
    into __tenant_owner_group_id;

    perform unsecure.assign_permission(_created_by, _user_id
        , __last_id, __tenant_owner_group_id, null, 'tenant_admin');

    select __group_id
    from unsecure.create_user_group(_created_by, _user_id, 'Tenant Members'
        , __last_id, true, true, false, true)
    into __tenant_member_group_id;

    perform unsecure.assign_permission(_created_by, _user_id
        , __last_id, __tenant_member_group_id, null, 'tenant_member');

    if
        (_tenant_owner_id is not null) then
        perform auth.create_owner(_created_by, _user_id, _tenant_owner_id, __last_id);
        --         perform unsecure.create_user_group_member(_created_by, _user_id, __last_id, __tenant_owner_group_id,
--                                                   _tenant_owner_id);
    end if;

    return query
        select *
        from tenant
        where tenant_id = __last_id;
end;
$$;

create function auth.get_tenants(_user_id bigint)
    returns table
            (
                __created       timestamptz,
                __created_by    text,
                __tenant_id     int,
                __uuid          text,
                __title         text,
                __code          text,
                __is_removable  bool,
                __is_assignable bool
            )
    language plpgsql
as
$$
begin
    perform
        auth.has_permission(1, _user_id, 'system.manage_tenants.get_tenants');

    return query
        select created,
               created_by,
               modified,
               modified_by,
               tenant_id,
               uuid::text,
               title,
               code,
               is_removable,
               is_assignable
        from tenant t;
end;
$$;

create function auth.get_tenant_by_id(_tenant_id int)
    returns table
            (
                __created       timestamptz,
                __created_by    text,
                __modified      timestamptz,
                __modified_by   text,
                __tenant_id     int,
                __uuid          text,
                __title         text,
                __code          text,
                __is_removable  bool,
                __is_assignable bool
            )
    language sql
as
$$
select created,
       created_by,
       modified,
       modified_by,
       tenant_id,
       uuid::text,
       title,
       code,
       is_removable,
       is_assignable
from tenant t
where tenant_id = _tenant_id;
$$;

create
    or replace function auth.get_tenant_users(_requested_by text, _user_id bigint, _tenant_id int)
    returns table
            (
                __user_id      bigint,
                __username     text,
                __display_name text,
                __user_groups  text[]
            )
    language plpgsql
as
$$
begin
    perform
        auth.has_permission(_tenant_id, _user_id, 'system.manage_tenants.get_users');

    return query with tenant_users as (select ui.user_id,
                                              ui.username,
                                              ui.display_name,
                                              ugs.user_group_id,
                                              ugs.group_title,
                                              ugs.group_code,
                                              jsonb_build_object(variadic
                                                                 array ['user_group_id', ugs.user_group_id::text, 'code', ugs.group_code, 'title', ugs.group_title]) group_data
                                       from user_group_members ugs
                                                inner join user_info ui on ugs.user_id = ui.user_id
                                       where ugs.tenant_id = _tenant_id
                                       order by ui.display_name)
                 select tu.user_id, tu.username, tu.display_name, array_agg(tu.group_data::text)
                 from tenant_users tu
                 group by tu.user_id, tu.username, tu.display_name;

    perform
        add_journal_msg(_requested_by, _tenant_id, _user_id
            , format('User: %s requested a list of all users for tenant: %s'
                            , _requested_by, _tenant_id)
            , 'tenant', _tenant_id
            , null
            , 50005);
end;
$$;

create
    or replace function auth.get_tenant_groups(_requested_by text, _user_id bigint, _tenant_id int)
    returns table
            (
                __user_group_id integer,
                __group_code    text,
                __group_title   text,
                __is_external   bool,
                __is_assignable bool,
                __is_active     bool,
                __members_count bigint

            )
    language plpgsql
as
$$
begin
    perform
        auth.has_permission(_tenant_id, _user_id, 'system.manage_tenants.get_groups');

    return query
        select ugs.user_group_id,
               ugs.group_title,
               ugs.group_code,
               ugs.is_external,
               ugs.is_assignable,
               ugs.is_active,
               count(ugs.user_id)
        from user_group_members ugs
        where ugs.tenant_id = _tenant_id
        group by ugs.user_group_id, ugs.group_title, ugs.group_code, ugs.is_external, ugs.is_assignable,
                 ugs.is_active
        order by ugs.group_title;

    perform
        add_journal_msg(_requested_by, _tenant_id, _user_id
            , format('User: %s requested a list of all groups for tenant: %s'
                            , _requested_by, _tenant_id)
            , 'tenant', _tenant_id
            , null
            , 50006);
end;
$$;

create
    or replace function auth.get_tenant_members(_requested_by text, _user_id bigint, _tenant_id int)
    returns table
            (
                __user_id            bigint,
                __user_display_name  text,
                __user_code          text,
                __user_uuid          text,
                __user_tenant_groups text
            )
    language plpgsql
as
$$
begin
    perform
        auth.has_permission(_tenant_id, _user_id, 'system.manage_tenants.get_tenants');

    return query
        select ugs.user_id,
               ui.display_name as user_display_name,
               ui.code         as user_code,
               ui.uuid::text   as user_uuid,
               array_to_json(array_agg(distinct
                                       jsonb_build_object('user_group_id', ugs.user_group_id, 'group_title',
                                                          ugs.group_title,
                                                          'group_code', ugs.group_code))) ::text
        from user_group_members ugs
                 inner join user_info ui on ugs.user_id = ui.user_id
        where ugs.tenant_id = _tenant_id
        group by ugs.user_id, ui.display_name, ui.code, ui.uuid
        order by ui.display_name;

    perform
        add_journal_msg(_requested_by, _tenant_id, _user_id
            , format('User: %s requested a list of members for tenant: %s'
                            , _requested_by, _tenant_id)
            , 'tenant', _tenant_id
            , null
            , 50005);
end;
$$;


/***
 *     #######  ##      ## ##    ## ######## ########   ######
 *    ##     ## ##  ##  ## ###   ## ##       ##     ## ##    ##
 *    ##     ## ##  ##  ## ####  ## ##       ##     ## ##
 *    ##     ## ##  ##  ## ## ## ## ######   ########   ######
 *    ##     ## ##  ##  ## ##  #### ##       ##   ##         ##
 *    ##     ## ##  ##  ## ##   ### ##       ##    ##  ##    ##
 *     #######   ###  ###  ##    ## ######## ##     ##  ######
 */

create or replace function auth.create_owner(_created_by text, _user_id bigint, _target_user_id bigint, _tenant_id int
, _user_group_id int default null)
    returns table
            (
                __owner_id bigint
            )
    language plpgsql
    rows 1
as
$$
begin

    if not is_owner(_user_id, _tenant_id, _user_group_id)
        and not is_owner(_user_id, _tenant_id)
    then
        if _user_group_id is not null then
            perform auth.has_permission(_tenant_id, _user_id
                , 'system.manage_tenants.assign_group_owner');
        else
            perform auth.has_permission(_tenant_id, _user_id
                , 'system.manage_tenants.assign_owner');
        end if;
    end if;

    return query
        insert into owner (created_by, tenant_id, user_group_id, user_id)
            values (_created_by, _tenant_id, _user_group_id, _target_user_id)
            returning owner_id;

    perform
        add_journal_msg(_created_by, _tenant_id, _user_id
            , format('User: %s added new tenant/group owner in tenant: %s'
                            , _created_by, _tenant_id)
            , 'tenant', _tenant_id
            , array ['user_group_id', _user_group_id::text]
            , 50004);
end;
$$;

create function auth.delete_owner(_deleted_by text, _user_id bigint, _target_user_id bigint, _tenant_id int
, _user_group_id int)
    returns void
    language plpgsql
as
$$
begin
    if not is_owner(_user_id, _tenant_id, _user_group_id)
        and not is_owner(_user_id, _tenant_id)
    then
        if _user_group_id is not null then
            perform auth.has_permission(_tenant_id, _user_id
                , 'system.manage_tenants.assign_group_owner');
        else
            perform auth.has_permission(_tenant_id, _user_id
                , 'system.manage_tenants.assign_owner');
        end if;
    end if;

    delete
    from owner
    where user_id = _target_user_id
      and tenant_id = _tenant_id
      and user_group_id = _user_group_id;

    perform
        add_journal_msg(_deleted_by, _tenant_id, _user_id
            , format('User: %s deleted new tenant/group owner in tenant: %s'
                            , _deleted_by, _tenant_id)
            , 'tenant', _tenant_id
            , array ['user_group_id', _user_group_id::text]
            , 50004);
end;
$$;


/***
 *    ########  ######## ########  ##     ## ####  ######   ######  ####  #######  ##    ##  ######
 *    ##     ## ##       ##     ## ###   ###  ##  ##    ## ##    ##  ##  ##     ## ###   ## ##    ##
 *    ##     ## ##       ##     ## #### ####  ##  ##       ##        ##  ##     ## ####  ## ##
 *    ########  ######   ########  ## ### ##  ##   ######   ######   ##  ##     ## ## ## ##  ######
 *    ##        ##       ##   ##   ##     ##  ##        ##       ##  ##  ##     ## ##  ####       ##
 *    ##        ##       ##    ##  ##     ##  ##  ##    ## ##    ##  ##  ##     ## ##   ### ##    ##
 *    ##        ######## ##     ## ##     ## ####  ######   ######  ####  #######  ##    ##  ######
 */

create function unsecure.assign_permission(_created_by text, _user_id bigint, _tenant_id int,
                                           _user_group_id int default null,
                                           _target_user_id bigint default null,
                                           _perm_set_code text default null, _perm_code text default null)
    returns setof auth.permission_assignment
    language plpgsql
as
$$
declare
    __last_id               int;
    __perm_set_id           int;
    __perm_set_assignable   bool;
    __permission_id         int;
    __permission_assignable bool;
begin

    if _user_group_id is null and _target_user_id is null then
        perform error.raise_52272();
    end if;

    if
        _perm_set_code is null and _perm_code is null then
        perform error.raise_52273();
    end if;

    if _user_group_id is not null and not exists(select
                                                 from user_group ug
                                                 where ug.user_group_id = _user_group_id) then
        perform error.raise_52171(_user_group_id);
    end if;

    if _target_user_id is not null and not exists(select
                                                  from user_info ui
                                                  where ui.user_id = _target_user_id) then
        perform error.raise_52103(_target_user_id);
    end if;

    if
        _perm_set_code is not null then
        select perm_set_id, is_assignable
        from auth.perm_set
        where code = _perm_set_code
        into __perm_set_id, __perm_set_assignable;

        if __perm_set_id is null then
            perform error.raise_52175(_perm_set_code);

        end if;
    end if;

    if _perm_code is not null then
        select permission.permission_id, is_assignable
        from auth.permission
        where code = _perm_code
        into __permission_id, __permission_assignable;

        if
            __permission_id is null then
            perform error.raise_52176(_perm_set_code);

        end if;
    end if;

    insert into auth.permission_assignment (created_by, tenant_id, group_id, user_id, perm_set_id, permission_id)
    values (_created_by, _tenant_id, _user_group_id, _user_id, __perm_set_id, __permission_id)
    returning assignment_id
        into __last_id;

    return query
        select *
        from auth.permission_assignment
        where assignment_id = __last_id;

    if
        _user_group_id is not null then
        perform add_journal_msg(_created_by, _tenant_id, _user_id
            , format('User: %s assigned new permission: %s to group: %s in tenant: %s'
                                    , _created_by, coalesce(_perm_set_code, _perm_code), _user_group_id, _tenant_id)
            , 'group', _user_group_id
            , array ['assignment_id', __last_id::text, 'perm_set_code', _perm_set_code, 'permission_code', _perm_code]
            , 50304);
    else
        perform add_journal_msg(_created_by, _tenant_id, _user_id
            , format('User: %s assigned new permission: %s to user: %s in tenant: %s'
                                    , _created_by, coalesce(_perm_set_code, _perm_code), _target_user_id, _tenant_id)
            , 'user', _target_user_id
            , array ['assignment_id', __last_id::text, 'perm_set_code', _perm_set_code, 'permission_code', _perm_code]
            , 50304);
    end if;
end;
$$;

create function unsecure.unassign_permission(_deleted_by text, _user_id bigint, _tenant_id int,
                                             _assignment_id int)
    returns setof auth.permission_assignment
    language plpgsql
as
$$
declare
    __user_group_id  int;
    __target_user_id int;
begin

    select group_id, user_id
    from auth.permission_assignment pa
    where pa.assignment_id = _assignment_id
    into __user_group_id, __target_user_id;

    return query
        delete
            from auth.permission_assignment
                where assignment_id = _assignment_id
                returning *;

    if
        __user_group_id is not null then
        perform add_journal_msg(_deleted_by, _tenant_id, _user_id
            , format('User: %s unassigned permission from group: %s in tenant: %s'
                                    , _deleted_by, __user_group_id, _tenant_id)
            , 'group', __user_group_id
            , array ['assignment_id', _assignment_id::text]
            , 50305);
    else
        perform add_journal_msg(_deleted_by, _tenant_id, _user_id
            , format('User: %s unassigned permission from user: %s in tenant: %s'
                                    , _deleted_by, __user_group_id, _tenant_id)
            , 'user', __target_user_id
            , array ['assignment_id', _assignment_id::text]
            , 50304);
    end if;
end;

$$;

create function unsecure.set_permission_as_assignable(_modified_by text, _user_id bigint,
                                                      _permission_id int default null,
                                                      _permission_full_code text default null,
                                                      _is_assignable bool default true)
    returns setof auth.permission_assignment
    language plpgsql
as
$$
declare
    __permission_id        int;
    __permission_full_code text;
begin

    if
        _permission_id is null and _permission_full_code is null then
        perform error.raise_52274();
    end if;

    __permission_id := _permission_id;

    if
        __permission_id is null then
        select permission_id
        from auth.permission
        where full_code = _permission_full_code
        into __permission_id;

        if
            __permission_id is null then
            perform error.raise_52275(_permission_full_code);
        end if;
    end if;

    update auth.permission
    set modified      = now(),
        modified_by   = _modified_by,
        is_assignable = _is_assignable
    where permission_id = __permission_id
    returning full_code
        into __permission_full_code;

    perform
        add_journal_msg(_modified_by, null, _user_id
            , format('User: %s set permission: %s as assignable: %s'
                            , _modified_by, __permission_full_code, _is_assignable)
            , 'permission', __permission_id
            , null
            , 50306);
end;
$$;

create function auth.set_permission_as_assignable(_modified_by text, _user_id bigint,
                                                  _permission_id int default null,
                                                  _permission_full_code text default null,
                                                  _is_assignable bool default true)
    returns setof auth.permission_assignment
    language plpgsql
as
$$
begin
    perform
        auth.has_permission(null, _user_id, 'system.manage_permissions.update_permission');

    return query
        select *
        from unsecure.set_permission_as_assignable(_modified_by, _user_id, _permission_id, _permission_full_code,
                                                   _is_assignable);
end;
$$;


create function unsecure.assign_permission_as_system(_tenant_id int, _user_group_id int, _target_user_id bigint,
                                                     _perm_set_code text,
                                                     _perm_code text default null)
    returns setof auth.permission_assignment
    language plpgsql
as
$$
begin
    return query
        select *
        from unsecure.assign_permission('system', 1, _tenant_id, _user_group_id, _target_user_id, _perm_set_code,
                                        _perm_code);
end;

$$;

create function auth.assign_permission(_created_by text, _user_id bigint, _tenant_id int, _user_group_id int,
                                       _target_user_id bigint,
                                       _perm_set_code text,
                                       _perm_code text)
    returns setof auth.permission_assignment
    language plpgsql
as
$$
begin
    perform
        auth.has_permission(_tenant_id, _user_id, 'system.manage_permissions.assign_permission');

    return query
        select *
        from unsecure.assign_permission(_created_by, _user_id, _tenant_id
            , _user_group_id, _target_user_id
            , _perm_set_code
            , _perm_code);
end;

$$;

create function auth.unassign_permission(_deleted_by text, _user_id bigint, _tenant_id int, _assignment_id int)
    returns setof auth.permission_assignment
    language plpgsql
as
$$
begin
    perform
        auth.has_permission(_tenant_id, _user_id, 'system.manage_permissions.unassign_permission');

    return query
        select *
        from unsecure.unassign_permission(_deleted_by, _user_id, _tenant_id, _assignment_id);
end;
$$;

create function unsecure.update_permission_full_title(_perm_path ext.ltree) returns SETOF auth.permission
    language sql
    rows 1
as
$$
update auth.permission p
set full_title =
        case
            when _perm_path = '1'::ext.ltree then 'System'
            else
                (select array_to_string(
                                ARRAY(SELECT p_n2.title
                                      FROM auth.permission as p_n2
                                      WHERE p_n2.node_path @> p_n.node_path
                                        and p_n2.permission_id <> 1
                                      ORDER BY p_n2.node_path),
                                ' > ')
                 FROM auth.permission As p_n
                 where p_n.permission_id = p.permission_id)
            end
where p.node_path <@ _perm_path
returning *;
$$;

create function unsecure.update_permission_full_code(_perm_path ext.ltree) returns SETOF auth.permission
    language sql
    rows 1
as
$$
update auth.permission p
set full_code = (select ext.text2ltree(array_to_string(
        ARRAY(SELECT coalesce(p_n2.code, helpers.get_code(p_n2.title, '_'))
              FROM auth.permission as p_n2
              WHERE p_n2.node_path @> p_n.node_path
              ORDER BY p_n2.node_path),
        '.'))
                 FROM auth.permission As p_n
                 where p_n.permission_id = p.permission_id)
where p.node_path <@ _perm_path
returning *;
$$;

create
    or replace function unsecure.create_permission_by_path_as_system(_title text
, _parent_code text default ''
, _is_assignable bool default true)
    returns setof auth.permission
    language plpgsql
    rows 1
as
$$
declare
    __last_id     int;
    __p           ext.ltree;
    __parent_id   int;
    __parent_path text;
begin

    insert into auth.permission(created_by, modified_by, title, is_assignable, code)
    values ('system', 'system', _title, _is_assignable, helpers.get_code(_title, '_'))
    returning permission_id
        into __last_id;

    if
        (_parent_code = '') then
        begin
            if
                (lower(_title) = 'system') then
                __p := ext.text2ltree(__last_id::text);
            else
                __p := ext.text2ltree('1.' || __last_id::text);
            end if;

            update auth.permission
            set node_path = __p
            where permission_id = __last_id;
        end;
    else
        begin
            select p.permission_id, node_path::text
            from auth.permission p
            where p.full_code = ext.text2ltree(_parent_code)
            into __parent_id, __parent_path;

            __p := ext.text2ltree(__parent_path || '.' || __last_id::text);

            update auth.permission
            set node_path = __p
            where permission_id = __last_id;

            update auth.permission
            set has_children = true
            where permission_id = __parent_id;
        end;

    end if;

    perform unsecure.update_permission_full_title(__p);
    perform unsecure.update_permission_full_code(__p);

    return query
        select *
        from auth.permission
        where node_path = __p;
end;
$$;

create function auth.create_permission_by_path(_created_by text, _user_id int,
                                               _data_node_path text, _title text,
                                               _parent_path text default '',
                                               _is_assignable bool default true)
    returns setof auth.permission
    language plpgsql
    rows 1
as
$$
declare
    __last_id int;
    __p       ext.ltree;
begin

    perform
        auth.has_permission(_user_id, _data_node_path::ext.ltree, 'system.manage_permissions.add_permission');

    insert into auth.permission(created_by, modified_by, title, is_assignable, code)
    values (_created_by, _created_by, _title, _is_assignable, helpers.get_code(_title))
    returning permission_id
        into __last_id;

    if
        (_parent_path = '') then
        begin
            if
                (lower(_title) != 'system')
            then
                __p := ext.text2ltree('1.' || __last_id::text);
            else
                __p := ext.text2ltree('1');
            end if;

            update auth.permission
            set node_path = __p
            where permission_id = __last_id;
        end;
    else
        begin
            __p := ext.text2ltree(_parent_path || '.' || __last_id::varchar);

            update auth.permission
            set node_path = __p
            where permission_id = __last_id;

            update auth.permission
            set has_children = true
            where node_path = ext.text2ltree(_parent_path);
        end;

    end if;

    perform unsecure.update_permission_full_title(__p);
    perform unsecure.update_permission_full_code(__p);

    return query
        select *
        from auth.permission
        where permission_id = __last_id;
end;
$$;

create
    or replace function auth.create_permission_by_code(_created_by text, _user_id int, _title text,
                                                       _parent_code text default '',
                                                       _is_assignable bool default true)
    returns setof auth.permission
    language plpgsql
    rows 1
as
$$
declare
    __last_id     int;
    __p           ext.ltree;
    __parent_id   int;
    __parent_path text;
begin

    perform
        auth.has_permission(_user_id, 'system.manage_permissions.add_permission');

    insert into auth.permission(created_by, modified_by, title, is_assignable, code)
    values (_created_by, _created_by, _title, _is_assignable, helpers.get_code(_title))
    returning permission_id
        into __last_id;

    if
        (_parent_code = '') then
        begin
            __p := ext.text2ltree('1.' || __last_id::text);

            update auth.permission
            set node_path = __p
            where permission_id = __last_id;
        end;
    else
        begin
            select p.permission_id, node_path::text
            from auth.permission p
            where p.full_code = ext.text2ltree(_parent_code)
            into __parent_id, __parent_path;

            __p := ext.text2ltree(__parent_path || '.' || __last_id::text);

            update auth.permission
            set node_path = __p
            where permission_id = __last_id;

            update auth.permission
            set has_children = true
            where permission_id = __parent_id;
        end;

    end if;

    perform unsecure.update_permission_full_title(__p);
    perform unsecure.update_permission_full_code(__p);

    return query
        select *
        from auth.permission
        where node_path = __p;
end;
$$;


create function unsecure.create_perm_set(
    _created_by text,
    _user_id bigint,
    _title text,
    _tenant_id int default null,
    _is_system bool default false,
    _is_assignable bool default true,
    _permissions text[] default null)
    returns setof auth.perm_set
    language plpgsql
    rows 1
as
$$
declare
    __last_id int;
begin

    if
        exists(SELECT
               from unnest(_permissions) as perm_code
                        inner join auth.permission p
                                   on p.full_code = perm_code::ext.ltree and not p.is_assignable) then
        perform error.raise_52178();
    end if;

    -- noinspection SqlInsertValues
    insert into auth.perm_set(created_by, modified_by, tenant_id, title, is_system, is_assignable)
    values (_created_by, _created_by, _tenant_id, _title, _is_system, _is_assignable)
    returning perm_set_id
        into __last_id;

    insert into auth.perm_set_perm(created_by, perm_set_id, permission_id)
    SELECT _created_by, __last_id, p.permission_id
    from unnest(_permissions) as perm_code
             inner join auth.permission p
                        on p.full_code = perm_code::ext.ltree;

    perform
        add_journal_msg(_created_by, _tenant_id, _user_id
            , format('User: %s created new permission set: %s'
                            , _created_by, _title)
            , 'perm_set', __last_id
            ,
                        array ['title', _title, 'is_system', _is_system::text, 'is_assignable', _is_assignable::text, 'permissions', array_to_string(_permissions, ', ')]
            , 50301);

    return query
        select *
        from auth.perm_set
        where perm_set_id = __last_id;
end;
$$;

create function unsecure.create_perm_set_as_system(
    _title text,
    _tenant_id int default null,
    _is_system bool default false,
    _is_assignable bool default true,
    _permissions text[] default null)
    returns setof auth.perm_set
    language sql
    rows 1
as
$$

select *
from unsecure.create_perm_set('system', 1, _title, _tenant_id, _is_system, _is_assignable, _permissions);

$$;

create function auth.create_perm_set(
    _created_by text,
    _user_id text,
    _title text,
    _tenant_id int default null,
    _is_system bool default false,
    _is_assignable bool default true,
    _permissions text[] default null)
    returns setof auth.perm_set
    language plpgsql
    rows 1
as
$$
begin

    perform
        auth.has_permission(_tenant_id, _user_id, 'system.manage_permissions.create_permission_set');

    return query
        select *
        from unsecure.create_perm_set(_created_by, _user_id, _title, _tenant_id, _is_system, _is_assignable,
                                      _permissions);
end;
$$;

create function unsecure.update_perm_set(
    _modified_by text,
    _user_id text,
    _tenant_id int,
    _perm_set_id int,
    _title text,
    _is_assignable bool default true
)
    returns setof auth.perm_set
    language plpgsql
    rows 1
as
$$
declare
    __last_id int;
begin

    -- noinspection SqlInsertValues
    update perm_set
    set modified      = now(),
        modified_by   = _modified_by,
        title         = _title,
        is_assignable = _is_assignable
    where perm_set_id = _perm_set_id
    returning perm_set_id
        into __last_id;

    perform
        add_journal_msg(_modified_by, _tenant_id, _user_id
            , format('User: %s updated permission set: %s'
                            , _modified_by, _title)
            , 'perm_set', __last_id
            ,
                        array ['title', _title, 'is_assignable', _is_assignable::text]
            , 50302);

    return query
        select *
        from auth.perm_set
        where perm_set_id = __last_id;
end;
$$;

create function auth.update_perm_set(
    _modified_by text,
    _user_id text,
    _tenant_id int,
    _perm_set_id int,
    _title text,
    _is_assignable bool default true
)
    returns setof auth.perm_set
    language plpgsql
    rows 1
as
$$
begin

    if
        not exists(select from auth.perm_set where perm_set_id = _perm_set_id and tenant_id = _tenant_id) then
        perform error.raise_52177(_perm_set_id, _tenant_id);

    end if;

    perform
        auth.has_permission(_tenant_id, _user_id, 'system.manage_permissions.update_permission_set');

    return query
        select *
        from unsecure.update_perm_set(_modified_by, _user_id, _tenant_id
            , _perm_set_id, _title, _is_assignable);
end;
$$;

create
    or replace function unsecure.add_perm_set_permissions(_created_by text, _user_id bigint, _tenant_id int,
                                                          _perm_set_id int, _permissions text[] default null)
    returns table
            (
                __perm_set_id     int,
                __perm_set_code   text,
                __permission_id   int,
                __permission_code text
            )
    language plpgsql
    rows 1
as
$$
begin

    if
        not exists(select from perm_set where perm_set_id = _perm_set_id and tenant_id = _tenant_id) then
        perform error.raise_52177(_perm_set_id, _tenant_id);
    end if;

    insert into perm_set_perm(created_by, perm_set_id, permission_id)
    SELECT _created_by, _perm_set_id, p.permission_id
    from unnest(_permissions) as perm_code
             left join permission p
                       on p.full_code = perm_code::ext.ltree
             left join perm_set_perm psp on p.permission_id = psp.permission_id and psp.perm_set_id = _perm_set_id
             left join perm_set ps on psp.perm_set_id = ps.perm_set_id
    where p.code is not null
      and psp.perm_set_id is null;

    perform
        add_journal_msg(_created_by, _tenant_id, _user_id
            , format('User: %s added permission to permission set: %s'
                            , _created_by, array_to_string(_permissions, ', '))
            , 'perm_set', _perm_set_id
            , array ['permissions', array_to_string(_permissions, ', ')]
            , 50311);

    return query
        select ps.perm_set_id, ps.code, p.permission_id, p.full_code::text
        from perm_set ps
                 inner join perm_set_perm psp on ps.perm_set_id = psp.perm_set_id
                 inner join permission p on p.permission_id = psp.permission_id
        where ps.perm_set_id = _perm_set_id
          and ps.tenant_id = _tenant_id
        order by p.full_code::text;
end;
$$;

create function auth.add_perm_set_permissions(_created_by text, _user_id bigint, _tenant_id int, _perm_set_id int,
                                              _permissions text[] default null)
    returns table
            (
                __perm_set_id     int,
                __perm_set_code   text,
                __permission_id   int,
                __permission_code text
            )
    language plpgsql
    rows 1
as
$$
begin

    perform
        auth.has_permission(_tenant_id, _user_id, 'system.manage_permissions.update_permission_set');

    return query
        select *
        from unsecure.add_perm_set_permissions(_created_by, _user_id, _tenant_id
            , _perm_set_id, _permissions);
end;
$$;


create
    or replace function unsecure.delete_perm_set_permissions(_deleted_by text, _user_id bigint, _tenant_id int,
                                                             _perm_set_id int, _permissions text[] default null)
    returns table
            (
                __perm_set_id     int,
                __perm_set_code   text,
                __permission_id   int,
                __permission_code text
            )
    language plpgsql
    rows 1
as
$$
begin

    if
        not exists(select from perm_set where perm_set_id = _perm_set_id and tenant_id = _tenant_id) then
        perform error.raise_52177(_perm_set_id, _tenant_id);
    end if;

    delete
    from perm_set_perm
    where perm_set_id = _perm_set_id
      and permission_id in (SELECT p.permission_id
                            from unnest(_permissions) as perm_code
                                     inner join permission p on p.full_code = perm_code::ext.ltree
                                     inner join perm_set_perm psp
                                                on p.permission_id = psp.permission_id and psp.perm_set_id = _perm_set_id
                                     inner join perm_set ps
                                                on psp.perm_set_id = ps.perm_set_id and ps.tenant_id = _tenant_id);

    perform
        add_journal_msg(_deleted_by, _tenant_id, _user_id
            , format('User: %s deleted permission from permission set: %s'
                            , _deleted_by, array_to_string(_permissions, ', '))
            , 'perm_set', _perm_set_id
            , array ['permissions', array_to_string(_permissions, ', ')]
            , 50313);

    return query
        select ps.perm_set_id, ps.code, p.permission_id, p.full_code::text
        from perm_set ps
                 inner join perm_set_perm psp on ps.perm_set_id = psp.perm_set_id
                 inner join permission p on p.permission_id = psp.permission_id
        where ps.perm_set_id = _perm_set_id
          and ps.tenant_id = _tenant_id
        order by p.full_code::text;
end;
$$;

create function auth.delete_perm_set_permissions(_created_by text, _user_id bigint, _tenant_id int, _perm_set_id int,
                                                 _permissions text[] default null)
    returns table
            (
                __perm_set_id     int,
                __perm_set_code   text,
                __permission_id   int,
                __permission_code text
            )
    language plpgsql
    rows 1
as
$$
begin

    perform
        auth.has_permission(_tenant_id, _user_id, 'system.manage_permissions.update_permission_set');

    return query
        select *
        from unsecure.delete_perm_set_permissions(_created_by, _user_id, _tenant_id
            , _perm_set_id, _permissions);
end;
$$;

/***
 *    ##     ##  ######  ######## ########   ######
 *    ##     ## ##    ## ##       ##     ## ##    ##
 *    ##     ## ##       ##       ##     ## ##
 *    ##     ##  ######  ######   ########   ######
 *    ##     ##       ## ##       ##   ##         ##
 *    ##     ## ##    ## ##       ##    ##  ##    ##
 *     #######   ######  ######## ##     ##  ######
 */

create function auth.enable_user(_modified_by text, _user_id bigint, _target_user_id bigint)
    returns table
            (
                __user_id   bigint,
                __is_active bool,
                __is_locked bool
            )
    language plpgsql
    rows 1
as
$$
begin
    perform
        auth.has_permission(null, _user_id, 'system.manage_users.enable_user');

    return query
        update user_info
            set modified_by = _modified_by
                , modified = now()
                , is_active = true
            where is_system = false
                and user_id = _target_user_id
            returning user_id
                , is_active
                , is_locked;

    perform
        add_journal_msg(_modified_by, null, _user_id
            , format('User: %s enabled user: %s'
                            , _modified_by, _target_user_id)
            , 'user', _target_user_id
            , null
            , 50104);
end;
$$;

create function auth.disable_user(_modified_by text, _user_id bigint, _target_user_id bigint)
    returns table
            (
                __user_id   bigint,
                __is_active bool,
                __is_locked bool
            )
    language plpgsql
    rows 1
as
$$
begin
    perform
        auth.has_permission(null, _user_id, 'system.manage_users.disable_user');

    return query
        update user_info
            set modified_by = _modified_by
                , modified = now()
                , is_active = false
            where is_system = false
                and user_id = _target_user_id
            returning user_id
                , is_active
                , is_locked;

    perform
        add_journal_msg(_modified_by, null, _user_id
            , format('User: %s disabled user: %s'
                            , _modified_by, _target_user_id)
            , 'user', _target_user_id
            , null
            , 50105);
end;
$$;

create function auth.unlock_user(_modified_by text, _user_id bigint, _target_user_id bigint)
    returns table
            (
                __user_id   bigint,
                __is_active bool,
                __is_locked bool
            )
    language plpgsql
    rows 1
as
$$
begin
    perform
        auth.has_permission(null, _user_id, 'system.manage_users.unlock_user');

    return query
        update user_info
            set modified_by = _modified_by
                , modified = now()
                , is_locked = false
            where is_system = false
                and user_id = _target_user_id
            returning user_id
                , is_active
                , is_locked;

    perform
        add_journal_msg(_modified_by, null, _user_id
            , format('User: %s unlocked user: %s'
                            , _modified_by, _target_user_id)
            , 'user', _target_user_id
            , null
            , 50106);
end;
$$;

create function auth.lock_user(_modified_by text, _user_id bigint, _target_user_id bigint)
    returns table
            (
                __user_id   bigint,
                __is_active bool,
                __is_locked bool
            )
    language plpgsql
    rows 1
as
$$
begin
    perform
        auth.has_permission(null, _user_id, 'system.manage_users.lock_user');

    return query
        update user_info
            set modified_by = _modified_by
                , modified = now()
                , is_locked = true
            where is_system = false
                and user_id = _target_user_id
            returning user_id
                , is_active
                , is_locked;

    perform
        add_journal_msg(_modified_by, null, _user_id
            , format('User: %s locked user: %s'
                            , _modified_by, _target_user_id)
            , 'user', _target_user_id
            , null
            , 50107);
end;
$$;

create function auth.enable_user_identity(_modified_by text, _user_id bigint, _target_user_id bigint,
                                          _provider_code text)
    returns table
            (
                __user_identity_id bigint,
                __is_active        bool
            )
    language plpgsql
    rows 1
as
$$
declare
    __user_identity_id bigint;
begin
    perform
        auth.has_permission(null, _user_id, 'system.manage_users.enable_user_identity');

    select user_identity_id
    from user_identity uid
             inner join user_info ui on uid.user_id = ui.user_id
    where not ui.is_system
      and uid.user_id = _target_user_id
      and provider_code = _provider_code
    into __user_identity_id;

    if
        __user_identity_id is null then
        perform error.raise_52111(_target_user_id, _provider_code);
    end if;

    return query
        update user_identity
            set modified_by = _modified_by
                , modified = now()
                , is_active = true
            where user_identity_id = __user_identity_id
            returning user_identity_id
                , is_active;

    perform
        add_journal_msg(_modified_by, null, _user_id
            , format('User: %s enabled user''s (id: %s) identity (provider code: %s)'
                            , _modified_by, _user_id, _target_user_id)
            , 'user', _target_user_id
            , array ['provider_code', _provider_code]
            , 50108);
end;
$$;

create function auth.disable_user_identity(_modified_by text, _user_id bigint, _target_user_id bigint,
                                           _provider_code text)
    returns table
            (
                __user_identity_id bigint,
                __is_active        bool
            )
    language plpgsql
    rows 1
as
$$
declare
    __user_identity_id bigint;
begin
    perform
        auth.has_permission(null, _user_id, 'system.manage_users.disable_user_identity');

    select user_identity_id
    from user_identity uid
             inner join user_info ui on uid.user_id = ui.user_id
    where not ui.is_system
      and uid.user_id = _target_user_id
      and provider_code = _provider_code
    into __user_identity_id;

    if
        __user_identity_id is null then
        perform error.raise_52111(_target_user_id, _provider_code);
    end if;

    return query
        update user_identity
            set modified_by = _modified_by
                , modified = now()
                , is_active = false
            where user_identity_id = __user_identity_id
            returning user_identity_id
                , is_active;

    perform
        add_journal_msg(_modified_by, null, _user_id
            , format('User: %s disabled user''s (id: %s) identity (provider code: %s)'
                            , _modified_by, _user_id, _target_user_id)
            , 'user', _target_user_id
            , array ['provider_code', _provider_code]
            , 50109);
end;
$$;


create
    or replace function unsecure.update_last_used_provider(_target_user_id bigint, _provider_code text)
    returns void
    language sql
as
$$
update user_info
set last_used_provider_code = _provider_code
where user_id = _target_user_id;
$$;

create
    or replace function auth.ensure_groups_and_permissions(_created_by text, _user_id bigint, _target_user_id bigint,
                                                           _tenant_id int,
                                                           _provider_code text,
                                                           _provider_groups text[] default null,
                                                           _provider_roles text[] default null)
    returns table
            (
                __tenant_id   int,
                __groups      text[],
                __permissions text[]
            )
    language plpgsql
    rows 1
as
$$
begin
    perform
        auth.has_permission(null, _user_id, 'system.authentication.ensure_permissions');

    update user_identity
    set modified_by     = _created_by,
        modified        = now(),
        provider_groups = _provider_groups,
        provider_roles  = _provider_roles
    where provider_code = _provider_code
      and user_id = _target_user_id;

    perform unsecure.recalculate_user_groups(_created_by
        , _target_user_id
        , _provider_code
        );

    return query
        select _tenant_id, up.__groups, up.__permissions
        from unsecure.recalculate_user_permissions(_created_by
                 , _tenant_id, _target_user_id) up;
end;
$$;

create function unsecure.create_user_info(_created_by text, _user_id bigint, _username text, _email text,
                                          _display_name text, _last_provider_code text)
    returns setof user_info
    language plpgsql
    rows 1
as
$$
declare
    __last_id             bigint;
    __normalized_username text;
    __normalized_email    text;
begin
    __normalized_username := lower(trim(_username));
    __normalized_email := lower(trim(_email));

    select user_id
    from user_info
    where username = __normalized_username
    into __last_id;

    if
        __last_id is null then
        insert into user_info (created_by, modified_by, username, email, display_name, last_used_provider_code)
        values (_created_by, _created_by, __normalized_username, __normalized_email, _display_name, _last_provider_code)
        returning user_id into __last_id;
    end if;

    return query
        select *
        from user_info
        where user_id = __last_id;

    perform
        add_journal_msg('system', null, _user_id
            , format('User: (id: %s) added new user: %s'
                            , _user_id, _username)
            , 'user', __last_id
            ,
                        array ['username', __normalized_username, 'email', __normalized_email
                            , 'display_name', _display_name]
            , _event_id := 50101);
end;
$$;

create function unsecure.create_user_identity(_created_by text, _user_id bigint, _target_user_id bigint,
                                              _provider_code text,
                                              _provider_uid text,
                                              _password_hash text default null,
                                              _user_data text default null,
                                              _password_salt text default null, _is_active bool default false
)
    returns table
            (
                __user_id       bigint,
                __provider_code text,
                __provider_uid  text
            )
    language plpgsql
    rows 1
as
$$
begin

    return query insert into user_identity (created_by, modified_by, provider_code, uid, user_id,
                                            user_data, password_hash, password_salt, is_active)
        values (_created_by, _created_by, _provider_code, _provider_uid, _target_user_id,
                _user_data::jsonb, _password_hash, _password_salt, _is_active)
        returning user_id, provider_code, uid;

    perform
        add_journal_msg('system', null, _user_id
            , format('User: (id: %s) added new user identity to user: %s'
                            , _user_id, _target_user_id)
            , 'user', _target_user_id
            , array ['provider_code', _provider_code, 'provider_uid', __provider_uid, 'is_active', _is_active::text]
            , _event_id := 50134);
end;
$$;

create function unsecure.update_user_password(_modified_by text, _user_id bigint, _target_user_id bigint,
                                              _password_hash text default null,
                                              _password_salt text default null)
    returns table
            (
                __user_id       bigint,
                __provider_code text,
                __provider_uid  text
            )
    language plpgsql
    rows 1
as
$$
begin

    return query
        update user_identity
            set modified = now(),
                modified_by = _modified_by, password_hash = _password_hash, password_salt = _password_salt
            where user_id = _target_user_id
                and provider_code = 'email'
            returning user_id
                , provider_code
                , uid;

    perform
        add_journal_msg('system', null, _user_id
            , format('User: (id: %s) changed user''s password (id: %s)'
                            , _user_id, _target_user_id)
            , 'user', _target_user_id
            , _event_id := 50136);
end;
$$;

create function auth.update_user_password(_modified_by text, _user_id bigint, _target_user_id bigint,
                                          _password_hash text,
                                          _ip_address text, _user_agent text, _origin text,
                                          _password_salt text default null)
    returns table
            (
                __user_id       bigint,
                __provider_code text,
                __provider_uid  text
            )
    language plpgsql
    rows 1
as
$$
begin

    if
        _user_id <> _target_user_id then
        perform auth.has_permission(null, _user_id, 'system.manage_users.change_password');
    end if;

    perform unsecure.create_auth_event(_modified_by, _user_id, 'change_password',
                                       _target_user_id, _ip_address, _user_agent, _origin);

    return query
        select *
        from unsecure.update_user_password(_modified_by, _user_id, _target_user_id,
                                           _password_hash,
                                           _password_salt);
end;
$$;


-- for email authentication
create
    or replace function auth.register_user(_created_by text, _user_id int, _email text, _password_hash text,
                                           _display_name text, _user_data text)
    returns table
            (
                __user_id      bigint,
                __code         text,
                __uuid         text,
                __username     text,
                __email        text,
                __display_name text
            )
    language plpgsql
    rows 1
as
$$
declare
    __normalized_email text;
    __new_user         user_info;
begin

    perform
        auth.has_permission(null, _user_id, 'system.manage_users.register_user');

    perform
        auth.validate_provider_is_active('email');

    if
        exists(
                select
                from user_identity ui
                where ui.provider_code = 'email'
                  and ui.uid = lower(__normalized_email)
            ) then
        perform error.raise_52102(__normalized_email);
    end if;

    select *
    from unsecure.create_user_info(_created_by, _user_id, _email, _email, _display_name,
                                   'email')
    into __new_user;

    perform unsecure.create_user_identity(_created_by, _user_id, __new_user.user_id
        , 'email', lower(trim(_email)), _password_hash);

    perform
        auth.update_user_data(_created_by, _user_id, __new_user.user_id, 'email', _user_data);

    return query
        select __new_user.user_id
             , __new_user.code
             , __new_user.uuid::text
             , __new_user.username
             , __new_user.email
             , __new_user.display_name;
--      from __new_user;
end;
$$;

create function unsecure.add_user_to_default_groups(_created_by text, _user_id bigint, _target_user_id bigint,
                                                    _tenant_id int)
    returns table
            (
                __user_id          bigint,
                __user_group_id    int,
                __user_group_code  text,
                __user_group_title text
            )
    language plpgsql
as
$$
DECLARE
    group_data RECORD;
begin

    if
        not exists(select from user_info where user_id = _user_id) then
        perform error.raise_52103(_user_id);
    end if;

    drop table if exists tmp_default_groups;

    create
        temporary table tmp_default_groups as
    select aug.user_group_id
    from active_user_groups aug
    where aug.tenant_id = _tenant_id
      and aug.is_default
      and user_group_id not in (select group_id
                                from user_group_member ugm
                                         inner join user_group ug on ug.user_group_id = ugm.group_id
                                where ugm.user_id = _user_id
                                  and ug.tenant_id = _tenant_id
                                  and ug.is_default);


    FOR group_data IN
        SELECT dg.*
        FROM tmp_default_groups dg
        LOOP
            perform unsecure.create_user_group_member(_created_by, _user_id,
                                                      _tenant_id, group_data.user_group_id,
                                                      _target_user_id) member;
        END LOOP;

    return query
        select user_id, user_group_id, group_code, group_title
        from user_group_members ugms
        where ugms.tenant_id = _tenant_id
          and ugms.user_id = _target_user_id;

    drop table tmp_default_groups;
end;
$$;

create function auth.add_user_to_default_groups(_created_by text, _user_id bigint, _target_user_id bigint,
                                                _tenant_id int)
    returns table
            (
                __user_id          bigint,
                __user_group_id    int,
                __user_group_code  text,
                __user_group_title text
            )
    language plpgsql
as
$$
begin

    perform
        auth.has_permission(_tenant_id, _user_id, 'system.manage_users.add_to_default_groups');

    return query
        select *
        from unsecure.add_user_to_default_groups(_created_by, _user_id, _target_user_id,
                                                 _tenant_id);
end;
$$;

create function auth.get_user_by_id(_user_id bigint)
    returns table
            (
                __user_id      bigint,
                __code         text,
                __uuid         text,
                __username     text,
                __email        text,
                __display_name text
            )
    language plpgsql
as
$$
begin
    if
        not exists(select
                   from user_info ui
                   where user_id = _user_id
            ) then
        perform error.raise_52103(_user_id);
    end if;

    return query
        select user_id,
               code,
               uuid::text,
               username,
               email,
               display_name
        from user_info ui
        where user_id = _user_id;
end;

$$;

create function auth.get_user_identity(_user_id bigint, _target_user_id bigint, _provider_code text)
    returns table
            (
                __user_identity_id bigint,
                __provider_code    text,
                __uid              text,
                __user_id          bigint,
                __provider_groups  text[],
                __provider_roles   text[],
                __user_data        jsonb
            )
    language plpgsql
as
$$
begin
    perform
        auth.has_permission(null, _user_id, 'system.manage_users.get_user_identity');

    return query
        select uid.user_identity_id,
               uid.provider_code,
               uid.uid,
               uid.uid,
               uid.user_id,
               uid.provider_groups,
               uid.provider_roles,
               uid.user_data
        from user_identity uid
        where user_id = _target_user_id
          and provider_code = _provider_code;
end;
$$;


create function auth.get_user_identity_by_email(_user_id bigint, _email text, _provider_code text)
    returns table
            (
                __user_identity_id bigint,
                __provider_code    text,
                __uid              text,
                __user_id          bigint,
                __provider_groups  text[],
                __provider_roles   text[],
                __user_data        jsonb
            )
    language plpgsql
as
$$
begin
    perform
        auth.has_permission(null, _user_id, 'system.manage_users.get_user_identity');

    return query
        select uid.user_identity_id,
               uid.provider_code,
               uid.uid,
               uid.user_id,
               uid.provider_groups,
               uid.provider_roles,
               uid.user_data
        from user_info ui
                 inner join user_identity uid on ui.user_id = uid.user_id
        where ui.email = _email
          and uid.provider_code = _provider_code;
end;
$$;



-- WARNING: returns password hash, do not use for anything else than authentication, SYSTEM account is the only one with proper permission
create function auth.get_user_by_email_for_authentication(_user_id int, _email text)
    returns table
            (
                __user_id       bigint,
                __code          text,
                __uuid          text,
                __username      text,
                __email         text,
                __display_name  text,
                __provider      text,
                __password_hash text,
                __password_salt text
            )
    language plpgsql
as
$$
declare
    __target_user_id     bigint;
    __target_uid_id      bigint;
    __normalized_email   text;
    __is_active          bool;
    __is_locked          bool;
    __is_identity_active bool;
    __can_login          bool;
begin

    perform
        auth.has_permission(null, _user_id, 'system.authentication.get_data');

    perform
        auth.validate_provider_is_active('email');

    __normalized_email := lower(trim(_email));

    select ui.user_id, uid.user_identity_id, ui.is_active, ui.is_locked, uid.is_active, ui.can_login
    from user_identity uid
             inner join user_info ui on uid.user_id = ui.user_id
    where uid.provider_code = 'email'
      and uid.uid = __normalized_email
    into __target_user_id, __target_uid_id, __is_active, __is_locked, __is_identity_active, __can_login;

    if
        __is_active is null then
        perform error.raise_52103(null, __normalized_email);
    end if;

    if
        not __can_login then
        perform error.raise_52112(__target_user_id);
    end if;

    perform
        update_last_used_provider(__target_user_id, 'email');

    if
        not __is_active then
        perform error.raise_52105(__target_user_id);

    end if;

    if
        not __is_identity_active then
        perform error.raise_52110(__target_user_id, 'email');
    end if;

    if
        __is_locked then
        perform error.raise_52106(__normalized_email);
    end if;

    return query
        select ui.user_id,
               ui.code,
               ui.uuid::text,
               ui.username,
               ui.email,
               ui.display_name,
               'email',
               uid.password_hash,
               uid.password_salt
        from user_identity uid
                 inner join user_info ui on uid.user_id = ui.user_id
        where uid.provider_code = 'email'
          and uid.uid = __normalized_email;
end;

$$;

-- for external authentication provider flows
create
    or replace function auth.ensure_user_from_provider(_created_by text, _user_id bigint, _provider_code text,
                                                       _provider_uid text,
                                                       _username text,
                                                       _display_name text, _email text default null,
                                                       _user_data text default null)
    returns table
            (
                __user_id      bigint,
                __code         text,
                __uuid         text,
                __username     text,
                __email        text,
                __display_name text
            )
    language plpgsql
as
$$
declare
    __last_id            bigint;
    __can_login          bool;
    __is_user_active     bool;
    __is_identity_active bool;
begin

    if
        lower(_provider_code) = 'email' then
        perform error.raise_52101(_username);
    end if;

    perform
        auth.validate_provider_is_active(_provider_code);

    select uid.user_id, u.is_active, uid.is_active, u.can_login
    from user_identity uid
             inner join user_info u on uid.user_id = u.user_id
    where uid.provider_code = _provider_code
      and uid.uid = _provider_uid
    into __last_id, __is_user_active, __is_identity_active, __can_login;

    if
        __last_id is null then
        select user_id
        from unsecure.create_user_info(_created_by, _user_id, lower(_username), lower(_email), _display_name,
                                       _provider_code)
        into __last_id;

        perform
            unsecure.create_user_identity(_created_by, _user_id, __last_id
                , _provider_code, _provider_uid, _is_active := true);

        perform
            auth.update_user_data(_email, _user_id, __last_id, _provider_code, _user_data);

    else
        if not __can_login then
            perform error.raise_52112(__last_id);
        end if;

        if
            not __is_user_active then
            perform error.raise_52105(__last_id);
        end if;

        if
            not __is_identity_active then
            perform error.raise_52110(__last_id, _provider_code);
        end if;
    end if;

    perform unsecure.update_last_used_provider(__last_id, _provider_code);

    return query
        select ui.user_id,
               ui.code,
               ui.uuid::text,
               ui.username,
               ui.email,
               ui.display_name
        from user_identity uid
                 inner join user_info ui on uid.user_id = ui.user_id
        where uid.provider_code = _provider_code
          and uid.uid = _provider_uid;
end;
$$;

create function auth.update_user_data(_modified_by text, _user_id bigint, _target_user_id bigint, _provider text,
                                      _user_data text)
    returns table
            (
                __user_id      bigint,
                __user_data_id bigint
            )
    language plpgsql
as
$$
begin

    if
        __user_id <> _target_user_id then
        perform auth.has_permission(null, _user_id, 'system.users.update_user');
    end if;


end;
$$;

--
-- create function auth.get_tenant_permissions(_tenant_id int, _user_id bigint)
--     returns table
--             (
--                 __user_id     bigint,
--                 __groups      text,
--                 __permissions text
--             )
--     language sql
-- as
-- $$
-- select upc.user_id, array_to_string(upc.groups, ';'), array_to_string(upc.permissions, ';')
-- from user_permission_cache upc
--          inner join public.tenant t on upc.tenant_id = t.tenant_id
-- where t.tenant_id = _tenant_id
--   and upc.user_id = _user_id;
-- $$;
--
--
-- create or replace function public.calculate_roles_and_permissions(_user_id bigint, _provider_groups text[], _provider_roles text[])
--     returns table
--             (
--                 __roles       text[],
--                 __permissions text[]
--             )
--     language plpgsql
--     rows 1
-- as
-- $$
-- declare
--     __user_id int;
--     __gs      text[];
--     __ps      text[];
-- begin
--
--     select user_id
--     from user_info ui
--     where ui.oid = _oid
--     into __user_id;
--
--     delete
--     from user_group_member
--     where user_id = __user_id
--       and (
--             (mapping_id is not null
--                 and group_id not in (select distinct ugm.group_id
--                                      from unnest(_provider_groups) g
--                                               inner join public.user_group_mapping ugm on ugm.mapped_object_id = g)
--                 )
--             or manual_assignment
--         );
--
--     insert into user_group_member(user_id, group_id, mapping_id, manual_assignment)
--     select distinct __user_id, ugm.group_id, ugm.ug_mapping_id, false
--     from unnest(_provider_groups) g
--              inner join public.user_group_mapping ugm
--                         on ugm.mapped_object_id = g
--     where ugm.group_id not in (select group_id from user_group_member where user_id = __user_id);
--
--     with users_groups as (select ugm.group_id
--                           from user_group_member ugm
--                           where ugm.user_id = __user_id),
--          groups as (select distinct ps.perm_set_id, ps.code
--                     from users_groups ug
--                              inner join permission_assignment uga on ug.group_id = uga.group_id
--                              inner join auth.perm_set ps on uga.perm_set_id = ps.perm_set_id),
--          user_permissions as (select sp.full_code
--                               from groups r
--                                        inner join auth.perm_set_perm psp on r.perm_set_id = psp.perm_set_id
--                                        join auth.permission p on psp.permission_id = p.permission_id
--                                        inner join auth.permission sp on sp.node_path <@ p.node_path
--                               order by sp.full_code)
--     select array_agg(distinct groups.code)                      gs,
--            array_agg(distinct user_permissions.full_code::text) ps
--     from groups,
--          user_permissions
--     into __gs, __ps;
--
--
--     return query
--         update auth.user_permission_cache
--             set modified = now()
--                 , groups = coalesce(__gs, array []::text[])
--                 , permissions = coalesce(__ps, array []::text[])
--             where user_id = __user_id
--             returning groups, permissions;
-- end;
-- $$;


/***
 *    ██╗███╗---██╗██╗████████╗██╗-█████╗-██╗---------██████╗--█████╗-████████╗-█████╗-
 *    ██║████╗--██║██║╚══██╔══╝██║██╔══██╗██║---------██╔══██╗██╔══██╗╚══██╔══╝██╔══██╗
 *    ██║██╔██╗-██║██║---██║---██║███████║██║---------██║--██║███████║---██║---███████║
 *    ██║██║╚██╗██║██║---██║---██║██╔══██║██║---------██║--██║██╔══██║---██║---██╔══██║
 *    ██║██║-╚████║██║---██║---██║██║--██║███████╗----██████╔╝██║--██║---██║---██║--██║
 *    ╚═╝╚═╝--╚═══╝╚═╝---╚═╝---╚═╝╚═╝--╚═╝╚══════╝----╚═════╝-╚═╝--╚═╝---╚═╝---╚═╝--╚═╝
 *    ---------------------------------------------------------------------------------
 */

create
    or replace function load_permission_initial_data()
    returns setof int
    language plpgsql
as
$$
declare
begin

    -- COMMMON WITH ALL DATABASES

    insert into const.sys_param(created_by, group_code, code, number_value)
    values ('initial', 'auth', 'perm_cache_timeout_in_s', 15); -- 15seconds intentionally for better debugging

    perform unsecure.create_system_user();
    perform unsecure.create_permission_by_path_as_system('System', _is_assignable := true);

    perform unsecure.create_user_group_as_system(null, 'System', true, true);

    perform unsecure.create_user_group_member_as_system('system', 'System', null);

    perform auth.lock_user_group('system', 1, null, 1);

    perform unsecure.create_perm_set_as_system('System', null, true, _is_assignable := true,
                                               _permissions := array ['system']);

    perform unsecure.assign_permission_as_system(null, 1, null, 'system');
    perform unsecure.set_permission_as_assignable('system', 1, 1, null, false);

    perform unsecure.create_primary_tenant();

    perform unsecure.create_permission_by_path_as_system('Authentication', 'system', false);
    perform unsecure.create_permission_by_path_as_system('Get data', 'system.authentication');
    perform unsecure.create_permission_by_path_as_system('Create auth event', 'system.authentication');

    perform unsecure.create_permission_by_path_as_system('Areas', 'system', false);
    perform unsecure.create_permission_by_path_as_system('Public', 'system.areas');
    perform unsecure.create_permission_by_path_as_system('Admin', 'system.areas');

    perform unsecure.create_permission_by_path_as_system('Token', 'system', false);

    perform unsecure.create_permission_by_path_as_system('Manage permissions', 'system', false);
    perform unsecure.create_permission_by_path_as_system('Create permission', 'system.manage_permissions');
    perform unsecure.create_permission_by_path_as_system('Update permission', 'system.manage_permissions');
    perform unsecure.create_permission_by_path_as_system('Delete permission', 'system.manage_permissions');
    perform unsecure.create_permission_by_path_as_system('Create permission set', 'system.manage_permissions');
    perform unsecure.create_permission_by_path_as_system('Update permission set', 'system.manage_permissions');
    perform unsecure.create_permission_by_path_as_system('Delete permission set', 'system.manage_permissions');
    perform unsecure.create_permission_by_path_as_system('Assign permission', 'system.manage_permissions');
    perform unsecure.create_permission_by_path_as_system('Unassign permission', 'system.manage_permissions');

    perform unsecure.create_permission_by_path_as_system('Manage users', 'system');
    perform unsecure.create_permission_by_path_as_system('Register user', 'system.manage_users');
    perform unsecure.create_permission_by_path_as_system('Add to default groups', 'system.manage_users');
    perform unsecure.create_permission_by_path_as_system('Enable user', 'system.manage_users');
    perform unsecure.create_permission_by_path_as_system('Disable user', 'system.manage_users');
    perform unsecure.create_permission_by_path_as_system('Lock user', 'system.manage_users');
    perform unsecure.create_permission_by_path_as_system('Unlock user', 'system.manage_users');
    perform unsecure.create_permission_by_path_as_system('Get user identity', 'system.manage_users');
    perform unsecure.create_permission_by_path_as_system('Enable user identity', 'system.manage_users');
    perform unsecure.create_permission_by_path_as_system('Disable user identity', 'system.manage_users');
    perform unsecure.create_permission_by_path_as_system('Change password', 'system.manage_users');

    perform unsecure.create_permission_by_path_as_system('Manage tenants', 'system');
    perform unsecure.create_permission_by_path_as_system('Create tenant', 'system.manage_tenants');
    perform unsecure.create_permission_by_path_as_system('Update tenant', 'system.manage_tenants');
    perform unsecure.create_permission_by_path_as_system('Assign owner', 'system.manage_tenants');
    perform unsecure.create_permission_by_path_as_system('Assign group owner', 'system.manage_tenants');
    perform unsecure.create_permission_by_path_as_system('Get tenants', 'system.manage_tenants');
    perform unsecure.create_permission_by_path_as_system('Get users', 'system.manage_tenants');
    perform unsecure.create_permission_by_path_as_system('Get groups', 'system.manage_tenants');


    perform unsecure.create_permission_by_path_as_system('Manage providers', 'system');
    perform unsecure.create_permission_by_path_as_system('Create provider', 'system.manage_providers');
    perform unsecure.create_permission_by_path_as_system('Update provider', 'system.manage_providers');
    perform unsecure.create_permission_by_path_as_system('Delete provider', 'system.manage_providers');
    perform unsecure.create_permission_by_path_as_system('Get users', 'system.manage_providers');

    perform unsecure.create_permission_by_path_as_system('Manage groups', 'system');
    perform unsecure.create_permission_by_path_as_system('Get group', 'system.manage_groups');
    perform unsecure.create_permission_by_path_as_system('Create group', 'system.manage_groups');
    perform unsecure.create_permission_by_path_as_system('Update group', 'system.manage_groups');
    perform unsecure.create_permission_by_path_as_system('Delete group', 'system.manage_groups');
    perform unsecure.create_permission_by_path_as_system('Lock group', 'system.manage_groups');
    perform unsecure.create_permission_by_path_as_system('Get groups', 'system.manage_groups');
    perform unsecure.create_permission_by_path_as_system('Create member', 'system.manage_groups');
    perform unsecure.create_permission_by_path_as_system('Delete member', 'system.manage_groups');
    perform unsecure.create_permission_by_path_as_system('Get members', 'system.manage_groups');
    perform unsecure.create_permission_by_path_as_system('Create mapping', 'system.manage_groups');
    perform unsecure.create_permission_by_path_as_system('Delete mapping', 'system.manage_groups');

    perform unsecure.create_perm_set_as_system('System admin', 1, true, _is_assignable := true,
                                               _permissions := array ['system.manage_tenants', 'system.manage_providers'
                                                   , 'system.manage_users','system.manage_groups']);

    perform unsecure.create_perm_set_as_system('Tenant creator', 1, true, _is_assignable := true,
                                               _permissions := array ['system.manage_tenants.create_tenant']);

    perform unsecure.create_perm_set_as_system('Tenant admin', 1, true, _is_assignable := true,
                                               _permissions := array ['system.manage_tenants']);

    perform unsecure.create_perm_set_as_system('Tenant owner', null, true, _is_assignable := true,
                                               _permissions := array ['system.manage_groups'
                                                   , 'system.manage_tenants.update_tenant'
                                                   , 'system.manage_tenants.assign_owner'
                                                   , 'system.manage_tenants.get_users']);

    perform unsecure.create_perm_set_as_system('Tenant member', null, true, _is_assignable := true,
                                               _permissions := array ['system.manage_tenants.get_groups'
                                                   , 'system.manage_tenants.get_users']);

    perform unsecure.create_user_group_as_system(1, 'Tenant admins', true, true);
    perform unsecure.assign_permission_as_system(1, 2, null, 'tenant_admin');

    perform unsecure.create_user_group_as_system(1, 'System admins', true, true);
    perform unsecure.assign_permission_as_system(1, 3, null, 'system_admin');


    perform
        auth.create_provider('initial', 1, 'email', 'Email authentication', false);
    perform
        auth.create_provider('initial', 1, 'aad', 'Azure authentication', false);

    insert into const.auth_event_type(code)
    values ('add_user_identity');
    insert into const.auth_event_type(code)
    values ('remove_user_identity');
    insert into const.auth_event_type(code)
    values ('email_verification');
    insert into const.auth_event_type(code)
    values ('phone_verification');
    insert into const.auth_event_type(code)
    values ('request_password_reset');
    insert into const.auth_event_type(code)
    values ('change_password');

    insert into const.token_type(code, default_expiration_in_seconds)
    values ('email_verification', 1 * 60 * 60);
    insert into const.token_type(code, default_expiration_in_seconds)
    values ('phone_verification', 10 * 60);
    insert into const.token_type(code, default_expiration_in_seconds)
    values ('password_reset', 10 * 60);
    insert into const.token_type(code, default_expiration_in_seconds)
    values ('invitation', 5 * 24 * 60 * 60);

    insert into const.token_channel(code)
    values ('email');
    insert into const.token_channel(code)
    values ('mobile_phone');

    insert into const.token_state(code)
    values ('valid');
    insert into const.token_state(code)
    values ('invalid');
    insert into const.token_state(code)
    values ('expired');
    insert into const.token_state(code)
    values ('used');


    -- UNIQUE FOR THIS DATABASE

--     insert into tenant (created_by, modified_by, name, code, is_removable, is_assignable)
--     values ('system', 'system', 'App 1', 'app1', true, true)
--          , ('system', 'system', 'App 2', 'app2', true, true);

    perform
        auth.enable_provider('system', 1, 'aad');
    perform
        auth.enable_provider('system', 1, 'email');

end


$$;

/***
 *    ██████╗--██████╗-███████╗████████╗-----██████╗██████╗-███████╗-█████╗-████████╗███████╗
 *    ██╔══██╗██╔═══██╗██╔════╝╚══██╔══╝----██╔════╝██╔══██╗██╔════╝██╔══██╗╚══██╔══╝██╔════╝
 *    ██████╔╝██║---██║███████╗---██║-------██║-----██████╔╝█████╗--███████║---██║---█████╗--
 *    ██╔═══╝-██║---██║╚════██║---██║-------██║-----██╔══██╗██╔══╝--██╔══██║---██║---██╔══╝--
 *    ██║-----╚██████╔╝███████║---██║-------╚██████╗██║--██║███████╗██║--██║---██║---███████╗
 *    ╚═╝------╚═════╝-╚══════╝---╚═╝--------╚═════╝╚═╝--╚═╝╚══════╝╚═╝--╚═╝---╚═╝---╚══════╝
 *    ---------------------------------------------------------------------------------------
 */

select *
from load_permission_initial_data();

select *
from stop_version_update('1', 'keen_auth_permissions');